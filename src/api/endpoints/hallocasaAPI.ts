/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * Hallocasa API
 * Hallocasa API Documentation
 * OpenAPI spec version: v1
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  Alert,
  Attachment,
  AuthInfoDto,
  AutopilotUser,
  BaseFilterResult,
  Brokerage,
  ChangePublicationStatus2Body,
  ChatAllowance,
  ChatTicket,
  CheckoutSessionDto,
  Contract,
  Country,
  CountryPhonePrefix,
  Currency,
  CustomerSessionDto,
  ExchangeRateMap,
  FBPropertyDto,
  Favorite,
  FetchPublishedTestimonials1Params,
  FetchReceivedTestimonials1Params,
  Find1Params,
  FindArchivedGroupsByUser1Params,
  FindGroupsByUser1Params,
  FindInactiveGroupsByUser1Params,
  FindInvitedGroupsByUser1Params,
  FindPropertiesByUser1Params,
  FindProperty1Params,
  FindRequestedGroupsByUser1Params,
  FindTestimonialsByUser1Params,
  GeoPlace,
  GetAlertResult1200,
  GetAll1Params,
  GetByUserParams,
  GetByUserWithResult1Params,
  GetChatSummaryByUser1Params,
  GetConversation1Params,
  GetGeoLocationsByLatLng1Params,
  GetGroupMembers1Params,
  GetLanguages1200,
  GetLanguages1Params,
  GetPropertyFieldOptions1200,
  GetPropertyFiltersParams,
  GetRecentProperties1Params,
  Group,
  GroupInviteParams,
  GroupMember,
  Language,
  LocaleSet,
  LogEntry,
  Message,
  NewsletterSubscriberDto,
  Notification,
  NotifyUploadRequest,
  PasswordRecoveryRequest,
  PhoneCodeCheckResource,
  PhoneCodeRequestResource,
  PreviewProperty2Params,
  PreviewPropertyParams,
  Property,
  PropertyFilter,
  PropertyFilterCriteria,
  PropertyFilterResult,
  PropertyFilterSubmission,
  PropertyKey,
  PropertyLocation,
  PropertyProposal,
  PropertyType,
  Register1Params,
  RequestActivationLink1Body,
  RequestToken1Body,
  RetrieveChatUserStatus1200,
  RetrieveEndorsementsByUser1Params,
  Skill,
  SkillEndorsement,
  SkilledUser,
  StripeEvent,
  SubscribedUser,
  SubscriptionPlanFeatureDto,
  Testimonial,
  TestimonialFilterResult,
  TestimonialRequest,
  TextTranslation,
  TranslateText1Params,
  UpdateGroupMembershipStatus1Params,
  UploadKyeroPropertiesParams,
  User,
  UserChatsSummary,
  UserFilterRequest,
  UserFilterResult,
  UserListRequest,
  UserSkill,
  UserSubscriptionDto,
  UserType,
  WeeklyAlertRange,
  XmlUrl,
} from "../model";

import { customInstance } from "../custom-instance";

/**
 * @summary Post a attachment request
 */
export const createAttachment1 = (
  attachment: Attachment,
  signal?: AbortSignal,
) => {
  return customInstance<Attachment>({
    url: `/chat/attachments`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: attachment,
    signal,
  });
};

export const getCreateAttachment1MutationOptions = <
  TError = Attachment,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAttachment1>>,
    TError,
    { data: Attachment },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAttachment1>>,
  TError,
  { data: Attachment },
  TContext
> => {
  const mutationKey = ["createAttachment1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAttachment1>>,
    { data: Attachment }
  > = (props) => {
    const { data } = props ?? {};

    return createAttachment1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAttachment1MutationResult = NonNullable<
  Awaited<ReturnType<typeof createAttachment1>>
>;
export type CreateAttachment1MutationBody = Attachment;
export type CreateAttachment1MutationError = Attachment;

/**
 * @summary Post a attachment request
 */
export const useCreateAttachment1 = <TError = Attachment, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createAttachment1>>,
      TError,
      { data: Attachment },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createAttachment1>>,
  TError,
  { data: Attachment },
  TContext
> => {
  const mutationOptions = getCreateAttachment1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get details to download a file
 */
export const retrieveAttachment1 = (fileId: string, signal?: AbortSignal) => {
  return customInstance<Attachment>({
    url: `/chat/attachments/${fileId}`,
    method: "GET",
    signal,
  });
};

export const getRetrieveAttachment1QueryKey = (fileId: string) => {
  return [`/chat/attachments/${fileId}`] as const;
};

export const getRetrieveAttachment1QueryOptions = <
  TData = Awaited<ReturnType<typeof retrieveAttachment1>>,
  TError = Attachment,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveAttachment1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRetrieveAttachment1QueryKey(fileId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof retrieveAttachment1>>
  > = ({ signal }) => retrieveAttachment1(fileId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!fileId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof retrieveAttachment1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RetrieveAttachment1QueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveAttachment1>>
>;
export type RetrieveAttachment1QueryError = Attachment;

export function useRetrieveAttachment1<
  TData = Awaited<ReturnType<typeof retrieveAttachment1>>,
  TError = Attachment,
>(
  fileId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveAttachment1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveAttachment1>>,
          TError,
          Awaited<ReturnType<typeof retrieveAttachment1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveAttachment1<
  TData = Awaited<ReturnType<typeof retrieveAttachment1>>,
  TError = Attachment,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveAttachment1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveAttachment1>>,
          TError,
          Awaited<ReturnType<typeof retrieveAttachment1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveAttachment1<
  TData = Awaited<ReturnType<typeof retrieveAttachment1>>,
  TError = Attachment,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveAttachment1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get details to download a file
 */

export function useRetrieveAttachment1<
  TData = Awaited<ReturnType<typeof retrieveAttachment1>>,
  TError = Attachment,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveAttachment1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRetrieveAttachment1QueryOptions(fileId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Notify a new file has been loaded in S3
 */
export const updateAttachment1 = (
  fileId: string,
  notifyUploadRequest: NotifyUploadRequest,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/chat/attachments/${fileId}/notify-upload`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: notifyUploadRequest,
    signal,
  });
};

export const getUpdateAttachment1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAttachment1>>,
    TError,
    { fileId: string; data: NotifyUploadRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAttachment1>>,
  TError,
  { fileId: string; data: NotifyUploadRequest },
  TContext
> => {
  const mutationKey = ["updateAttachment1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAttachment1>>,
    { fileId: string; data: NotifyUploadRequest }
  > = (props) => {
    const { fileId, data } = props ?? {};

    return updateAttachment1(fileId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAttachment1MutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAttachment1>>
>;
export type UpdateAttachment1MutationBody = NotifyUploadRequest;
export type UpdateAttachment1MutationError = unknown;

/**
 * @summary Notify a new file has been loaded in S3
 */
export const useUpdateAttachment1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAttachment1>>,
      TError,
      { fileId: string; data: NotifyUploadRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateAttachment1>>,
  TError,
  { fileId: string; data: NotifyUploadRequest },
  TContext
> => {
  const mutationOptions = getUpdateAttachment1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
 * @summary Get chat allowance for a user pair
 */
export const getChatAllowance1 = (userPair: string, signal?: AbortSignal) => {
  return customInstance<ChatAllowance>({
    url: `/chat/allowance/${userPair}`,
    method: "GET",
    signal,
  });
};

export const getGetChatAllowance1QueryKey = (userPair: string) => {
  return [`/chat/allowance/${userPair}`] as const;
};

export const getGetChatAllowance1QueryOptions = <
  TData = Awaited<ReturnType<typeof getChatAllowance1>>,
  TError = void,
>(
  userPair: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChatAllowance1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetChatAllowance1QueryKey(userPair);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getChatAllowance1>>
  > = ({ signal }) => getChatAllowance1(userPair, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userPair,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getChatAllowance1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetChatAllowance1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getChatAllowance1>>
>;
export type GetChatAllowance1QueryError = void;

export function useGetChatAllowance1<
  TData = Awaited<ReturnType<typeof getChatAllowance1>>,
  TError = void,
>(
  userPair: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChatAllowance1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChatAllowance1>>,
          TError,
          Awaited<ReturnType<typeof getChatAllowance1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetChatAllowance1<
  TData = Awaited<ReturnType<typeof getChatAllowance1>>,
  TError = void,
>(
  userPair: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChatAllowance1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChatAllowance1>>,
          TError,
          Awaited<ReturnType<typeof getChatAllowance1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetChatAllowance1<
  TData = Awaited<ReturnType<typeof getChatAllowance1>>,
  TError = void,
>(
  userPair: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChatAllowance1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get chat allowance for a user pair
 */

export function useGetChatAllowance1<
  TData = Awaited<ReturnType<typeof getChatAllowance1>>,
  TError = void,
>(
  userPair: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChatAllowance1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetChatAllowance1QueryOptions(userPair, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates the chat allowance settings between two users
 * @summary Update chat allowance for a user pair
 */
export const updateChatAllowance1 = (
  userPair: string,
  chatAllowance: ChatAllowance,
) => {
  return customInstance<ChatAllowance>({
    url: `/chat/allowance/${userPair}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: chatAllowance,
  });
};

export const getUpdateChatAllowance1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateChatAllowance1>>,
    TError,
    { userPair: string; data: ChatAllowance },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateChatAllowance1>>,
  TError,
  { userPair: string; data: ChatAllowance },
  TContext
> => {
  const mutationKey = ["updateChatAllowance1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateChatAllowance1>>,
    { userPair: string; data: ChatAllowance }
  > = (props) => {
    const { userPair, data } = props ?? {};

    return updateChatAllowance1(userPair, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateChatAllowance1MutationResult = NonNullable<
  Awaited<ReturnType<typeof updateChatAllowance1>>
>;
export type UpdateChatAllowance1MutationBody = ChatAllowance;
export type UpdateChatAllowance1MutationError = void;

/**
 * @summary Update chat allowance for a user pair
 */
export const useUpdateChatAllowance1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateChatAllowance1>>,
      TError,
      { userPair: string; data: ChatAllowance },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateChatAllowance1>>,
  TError,
  { userPair: string; data: ChatAllowance },
  TContext
> => {
  const mutationOptions = getUpdateChatAllowance1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves summaries of all chat conversations for a user
 * @summary Get the user chat summaries
 */
export const getChatSummaryByUser1 = (
  userId: number,
  params?: GetChatSummaryByUser1Params,
  signal?: AbortSignal,
) => {
  return customInstance<UserChatsSummary>({
    url: `/chat/user_summary/${userId}`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetChatSummaryByUser1QueryKey = (
  userId: number,
  params?: GetChatSummaryByUser1Params,
) => {
  return [`/chat/user_summary/${userId}`, ...(params ? [params] : [])] as const;
};

export const getGetChatSummaryByUser1QueryOptions = <
  TData = Awaited<ReturnType<typeof getChatSummaryByUser1>>,
  TError = void,
>(
  userId: number,
  params?: GetChatSummaryByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChatSummaryByUser1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetChatSummaryByUser1QueryKey(userId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getChatSummaryByUser1>>
  > = ({ signal }) => getChatSummaryByUser1(userId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getChatSummaryByUser1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetChatSummaryByUser1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getChatSummaryByUser1>>
>;
export type GetChatSummaryByUser1QueryError = void;

export function useGetChatSummaryByUser1<
  TData = Awaited<ReturnType<typeof getChatSummaryByUser1>>,
  TError = void,
>(
  userId: number,
  params: undefined | GetChatSummaryByUser1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChatSummaryByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChatSummaryByUser1>>,
          TError,
          Awaited<ReturnType<typeof getChatSummaryByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetChatSummaryByUser1<
  TData = Awaited<ReturnType<typeof getChatSummaryByUser1>>,
  TError = void,
>(
  userId: number,
  params?: GetChatSummaryByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChatSummaryByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getChatSummaryByUser1>>,
          TError,
          Awaited<ReturnType<typeof getChatSummaryByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetChatSummaryByUser1<
  TData = Awaited<ReturnType<typeof getChatSummaryByUser1>>,
  TError = void,
>(
  userId: number,
  params?: GetChatSummaryByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChatSummaryByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the user chat summaries
 */

export function useGetChatSummaryByUser1<
  TData = Awaited<ReturnType<typeof getChatSummaryByUser1>>,
  TError = void,
>(
  userId: number,
  params?: GetChatSummaryByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getChatSummaryByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetChatSummaryByUser1QueryOptions(
    userId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates and returns a chat ticket that can be used to establish a chat connection
 * @summary Retrieve a chat ticket for the authenticated user
 */
export const retrieveUserTicket1 = (signal?: AbortSignal) => {
  return customInstance<ChatTicket>({
    url: `/chat/ticket`,
    method: "GET",
    signal,
  });
};

export const getRetrieveUserTicket1QueryKey = () => {
  return [`/chat/ticket`] as const;
};

export const getRetrieveUserTicket1QueryOptions = <
  TData = Awaited<ReturnType<typeof retrieveUserTicket1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof retrieveUserTicket1>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetrieveUserTicket1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof retrieveUserTicket1>>
  > = ({ signal }) => retrieveUserTicket1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof retrieveUserTicket1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RetrieveUserTicket1QueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveUserTicket1>>
>;
export type RetrieveUserTicket1QueryError = void;

export function useRetrieveUserTicket1<
  TData = Awaited<ReturnType<typeof retrieveUserTicket1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserTicket1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveUserTicket1>>,
          TError,
          Awaited<ReturnType<typeof retrieveUserTicket1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveUserTicket1<
  TData = Awaited<ReturnType<typeof retrieveUserTicket1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserTicket1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveUserTicket1>>,
          TError,
          Awaited<ReturnType<typeof retrieveUserTicket1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveUserTicket1<
  TData = Awaited<ReturnType<typeof retrieveUserTicket1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserTicket1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve a chat ticket for the authenticated user
 */

export function useRetrieveUserTicket1<
  TData = Awaited<ReturnType<typeof retrieveUserTicket1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserTicket1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRetrieveUserTicket1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get a user connections
 */
export const findUserConnections2 = (userId: number, signal?: AbortSignal) => {
  return customInstance<User[]>({
    url: `/chat/users/${userId}/connections`,
    method: "GET",
    signal,
  });
};

export const getFindUserConnections2QueryKey = (userId: number) => {
  return [`/chat/users/${userId}/connections`] as const;
};

export const getFindUserConnections2QueryOptions = <
  TData = Awaited<ReturnType<typeof findUserConnections2>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserConnections2>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindUserConnections2QueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findUserConnections2>>
  > = ({ signal }) => findUserConnections2(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findUserConnections2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindUserConnections2QueryResult = NonNullable<
  Awaited<ReturnType<typeof findUserConnections2>>
>;
export type FindUserConnections2QueryError = void;

export function useFindUserConnections2<
  TData = Awaited<ReturnType<typeof findUserConnections2>>,
  TError = void,
>(
  userId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserConnections2>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findUserConnections2>>,
          TError,
          Awaited<ReturnType<typeof findUserConnections2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindUserConnections2<
  TData = Awaited<ReturnType<typeof findUserConnections2>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserConnections2>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findUserConnections2>>,
          TError,
          Awaited<ReturnType<typeof findUserConnections2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindUserConnections2<
  TData = Awaited<ReturnType<typeof findUserConnections2>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserConnections2>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a user connections
 */

export function useFindUserConnections2<
  TData = Awaited<ReturnType<typeof findUserConnections2>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserConnections2>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindUserConnections2QueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get a user Contracts
 */
export const findUserContracts1 = (signal?: AbortSignal) => {
  return customInstance<Contract[]>({
    url: `/contract`,
    method: "GET",
    signal,
  });
};

export const getFindUserContracts1QueryKey = () => {
  return [`/contract`] as const;
};

export const getFindUserContracts1QueryOptions = <
  TData = Awaited<ReturnType<typeof findUserContracts1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof findUserContracts1>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindUserContracts1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findUserContracts1>>
  > = ({ signal }) => findUserContracts1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findUserContracts1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindUserContracts1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findUserContracts1>>
>;
export type FindUserContracts1QueryError = void;

export function useFindUserContracts1<
  TData = Awaited<ReturnType<typeof findUserContracts1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserContracts1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findUserContracts1>>,
          TError,
          Awaited<ReturnType<typeof findUserContracts1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindUserContracts1<
  TData = Awaited<ReturnType<typeof findUserContracts1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserContracts1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findUserContracts1>>,
          TError,
          Awaited<ReturnType<typeof findUserContracts1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindUserContracts1<
  TData = Awaited<ReturnType<typeof findUserContracts1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserContracts1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a user Contracts
 */

export function useFindUserContracts1<
  TData = Awaited<ReturnType<typeof findUserContracts1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserContracts1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindUserContracts1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Save a user Contract
 */
export const save2 = (contract: Contract, signal?: AbortSignal) => {
  return customInstance<Contract>({
    url: `/contract`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: contract,
    signal,
  });
};

export const getSave2MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof save2>>,
    TError,
    { data: Contract },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof save2>>,
  TError,
  { data: Contract },
  TContext
> => {
  const mutationKey = ["save2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof save2>>,
    { data: Contract }
  > = (props) => {
    const { data } = props ?? {};

    return save2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type Save2MutationResult = NonNullable<
  Awaited<ReturnType<typeof save2>>
>;
export type Save2MutationBody = Contract;
export type Save2MutationError = void;

/**
 * @summary Save a user Contract
 */
export const useSave2 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof save2>>,
      TError,
      { data: Contract },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof save2>>,
  TError,
  { data: Contract },
  TContext
> => {
  const mutationOptions = getSave2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Get a message by conversation
 */
export const getConversation1 = (
  params?: GetConversation1Params,
  signal?: AbortSignal,
) => {
  return customInstance<Message[]>({
    url: `/chat/messages`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetConversation1QueryKey = (
  params?: GetConversation1Params,
) => {
  return [`/chat/messages`, ...(params ? [params] : [])] as const;
};

export const getGetConversation1QueryOptions = <
  TData = Awaited<ReturnType<typeof getConversation1>>,
  TError = void,
>(
  params?: GetConversation1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConversation1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetConversation1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getConversation1>>
  > = ({ signal }) => getConversation1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConversation1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetConversation1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getConversation1>>
>;
export type GetConversation1QueryError = void;

export function useGetConversation1<
  TData = Awaited<ReturnType<typeof getConversation1>>,
  TError = void,
>(
  params: undefined | GetConversation1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConversation1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConversation1>>,
          TError,
          Awaited<ReturnType<typeof getConversation1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetConversation1<
  TData = Awaited<ReturnType<typeof getConversation1>>,
  TError = void,
>(
  params?: GetConversation1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConversation1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConversation1>>,
          TError,
          Awaited<ReturnType<typeof getConversation1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetConversation1<
  TData = Awaited<ReturnType<typeof getConversation1>>,
  TError = void,
>(
  params?: GetConversation1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConversation1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a message by conversation
 */

export function useGetConversation1<
  TData = Awaited<ReturnType<typeof getConversation1>>,
  TError = void,
>(
  params?: GetConversation1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getConversation1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetConversation1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Post a message
 */
export const sendMessage1 = (message: Message, signal?: AbortSignal) => {
  return customInstance<Message>({
    url: `/chat/messages`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: message,
    signal,
  });
};

export const getSendMessage1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendMessage1>>,
    TError,
    { data: Message },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendMessage1>>,
  TError,
  { data: Message },
  TContext
> => {
  const mutationKey = ["sendMessage1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendMessage1>>,
    { data: Message }
  > = (props) => {
    const { data } = props ?? {};

    return sendMessage1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendMessage1MutationResult = NonNullable<
  Awaited<ReturnType<typeof sendMessage1>>
>;
export type SendMessage1MutationBody = Message;
export type SendMessage1MutationError = void;

/**
 * @summary Post a message
 */
export const useSendMessage1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendMessage1>>,
      TError,
      { data: Message },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sendMessage1>>,
  TError,
  { data: Message },
  TContext
> => {
  const mutationOptions = getSendMessage1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
 * @summary Get user notifications by type
 */
export const getByUserWithResult1 = (
  type:
    | "TO_BROKER__ALERT_CREATED"
    | "TO_USER__WEEKLY_PROPERTIES"
    | "TO_USER__WEEKLY_PAYED_SUBSCRIBERS"
    | "TO_USER__CUSTOMIZED_ALERT"
    | "TO_USER__WEEKLY_GROUP_PROPERTIES"
    | "TO_USER__NEWSLETTER_NEW_SUBSCRIBER"
    | "TO_USER__NEWSLETTER_CONFIRMATION"
    | "TO_USER__NEWSLETTER_LISTING",
  autopilotUser: AutopilotUser,
  params: GetByUserWithResult1Params,
  signal?: AbortSignal,
) => {
  return customInstance<Notification>({
    url: `/notifications/${type}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: autopilotUser,
    params,
    signal,
  });
};

export const getGetByUserWithResult1MutationOptions = <
  TError = string,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getByUserWithResult1>>,
    TError,
    {
      type:
        | "TO_BROKER__ALERT_CREATED"
        | "TO_USER__WEEKLY_PROPERTIES"
        | "TO_USER__WEEKLY_PAYED_SUBSCRIBERS"
        | "TO_USER__CUSTOMIZED_ALERT"
        | "TO_USER__WEEKLY_GROUP_PROPERTIES"
        | "TO_USER__NEWSLETTER_NEW_SUBSCRIBER"
        | "TO_USER__NEWSLETTER_CONFIRMATION"
        | "TO_USER__NEWSLETTER_LISTING";
      data: AutopilotUser;
      params: GetByUserWithResult1Params;
    },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getByUserWithResult1>>,
  TError,
  {
    type:
      | "TO_BROKER__ALERT_CREATED"
      | "TO_USER__WEEKLY_PROPERTIES"
      | "TO_USER__WEEKLY_PAYED_SUBSCRIBERS"
      | "TO_USER__CUSTOMIZED_ALERT"
      | "TO_USER__WEEKLY_GROUP_PROPERTIES"
      | "TO_USER__NEWSLETTER_NEW_SUBSCRIBER"
      | "TO_USER__NEWSLETTER_CONFIRMATION"
      | "TO_USER__NEWSLETTER_LISTING";
    data: AutopilotUser;
    params: GetByUserWithResult1Params;
  },
  TContext
> => {
  const mutationKey = ["getByUserWithResult1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getByUserWithResult1>>,
    {
      type:
        | "TO_BROKER__ALERT_CREATED"
        | "TO_USER__WEEKLY_PROPERTIES"
        | "TO_USER__WEEKLY_PAYED_SUBSCRIBERS"
        | "TO_USER__CUSTOMIZED_ALERT"
        | "TO_USER__WEEKLY_GROUP_PROPERTIES"
        | "TO_USER__NEWSLETTER_NEW_SUBSCRIBER"
        | "TO_USER__NEWSLETTER_CONFIRMATION"
        | "TO_USER__NEWSLETTER_LISTING";
      data: AutopilotUser;
      params: GetByUserWithResult1Params;
    }
  > = (props) => {
    const { type, data, params } = props ?? {};

    return getByUserWithResult1(type, data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetByUserWithResult1MutationResult = NonNullable<
  Awaited<ReturnType<typeof getByUserWithResult1>>
>;
export type GetByUserWithResult1MutationBody = AutopilotUser;
export type GetByUserWithResult1MutationError = string;

/**
 * @summary Get user notifications by type
 */
export const useGetByUserWithResult1 = <TError = string, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof getByUserWithResult1>>,
      TError,
      {
        type:
          | "TO_BROKER__ALERT_CREATED"
          | "TO_USER__WEEKLY_PROPERTIES"
          | "TO_USER__WEEKLY_PAYED_SUBSCRIBERS"
          | "TO_USER__CUSTOMIZED_ALERT"
          | "TO_USER__WEEKLY_GROUP_PROPERTIES"
          | "TO_USER__NEWSLETTER_NEW_SUBSCRIBER"
          | "TO_USER__NEWSLETTER_CONFIRMATION"
          | "TO_USER__NEWSLETTER_LISTING";
        data: AutopilotUser;
        params: GetByUserWithResult1Params;
      },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof getByUserWithResult1>>,
  TError,
  {
    type:
      | "TO_BROKER__ALERT_CREATED"
      | "TO_USER__WEEKLY_PROPERTIES"
      | "TO_USER__WEEKLY_PAYED_SUBSCRIBERS"
      | "TO_USER__CUSTOMIZED_ALERT"
      | "TO_USER__WEEKLY_GROUP_PROPERTIES"
      | "TO_USER__NEWSLETTER_NEW_SUBSCRIBER"
      | "TO_USER__NEWSLETTER_CONFIRMATION"
      | "TO_USER__NEWSLETTER_LISTING";
    data: AutopilotUser;
    params: GetByUserWithResult1Params;
  },
  TContext
> => {
  const mutationOptions = getGetByUserWithResult1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Retrieve a user chat
 */
export const retrieveChatUser1 = (id: number, signal?: AbortSignal) => {
  return customInstance<User>({
    url: `/chat/user/${id}`,
    method: "GET",
    signal,
  });
};

export const getRetrieveChatUser1QueryKey = (id: number) => {
  return [`/chat/user/${id}`] as const;
};

export const getRetrieveChatUser1QueryOptions = <
  TData = Awaited<ReturnType<typeof retrieveChatUser1>>,
  TError = void,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveChatUser1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetrieveChatUser1QueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof retrieveChatUser1>>
  > = ({ signal }) => retrieveChatUser1(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof retrieveChatUser1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RetrieveChatUser1QueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveChatUser1>>
>;
export type RetrieveChatUser1QueryError = void;

export function useRetrieveChatUser1<
  TData = Awaited<ReturnType<typeof retrieveChatUser1>>,
  TError = void,
>(
  id: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveChatUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveChatUser1>>,
          TError,
          Awaited<ReturnType<typeof retrieveChatUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveChatUser1<
  TData = Awaited<ReturnType<typeof retrieveChatUser1>>,
  TError = void,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveChatUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveChatUser1>>,
          TError,
          Awaited<ReturnType<typeof retrieveChatUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveChatUser1<
  TData = Awaited<ReturnType<typeof retrieveChatUser1>>,
  TError = void,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveChatUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve a user chat
 */

export function useRetrieveChatUser1<
  TData = Awaited<ReturnType<typeof retrieveChatUser1>>,
  TError = void,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveChatUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRetrieveChatUser1QueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Retrieve a user chat status
 */
export const retrieveChatUserStatus1 = (id: number, signal?: AbortSignal) => {
  return customInstance<RetrieveChatUserStatus1200>({
    url: `/chat/user/${id}/status`,
    method: "GET",
    signal,
  });
};

export const getRetrieveChatUserStatus1QueryKey = (id: number) => {
  return [`/chat/user/${id}/status`] as const;
};

export const getRetrieveChatUserStatus1QueryOptions = <
  TData = Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
  TError = void,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRetrieveChatUserStatus1QueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof retrieveChatUserStatus1>>
  > = ({ signal }) => retrieveChatUserStatus1(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RetrieveChatUserStatus1QueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveChatUserStatus1>>
>;
export type RetrieveChatUserStatus1QueryError = void;

export function useRetrieveChatUserStatus1<
  TData = Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
  TError = void,
>(
  id: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
          TError,
          Awaited<ReturnType<typeof retrieveChatUserStatus1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveChatUserStatus1<
  TData = Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
  TError = void,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
          TError,
          Awaited<ReturnType<typeof retrieveChatUserStatus1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveChatUserStatus1<
  TData = Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
  TError = void,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve a user chat status
 */

export function useRetrieveChatUserStatus1<
  TData = Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
  TError = void,
>(
  id: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveChatUserStatus1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRetrieveChatUserStatus1QueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a list of all available country phone prefixes with their details
 * @summary Returns all country-phone-prefixes list
 */
export const get2 = (signal?: AbortSignal) => {
  return customInstance<CountryPhonePrefix[]>({
    url: `/country-phone-prefixes`,
    method: "GET",
    signal,
  });
};

export const getGet2QueryKey = () => {
  return [`/country-phone-prefixes`] as const;
};

export const getGet2QueryOptions = <
  TData = Awaited<ReturnType<typeof get2>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof get2>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGet2QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get2>>> = ({
    signal,
  }) => get2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof get2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type Get2QueryResult = NonNullable<Awaited<ReturnType<typeof get2>>>;
export type Get2QueryError = void;

export function useGet2<
  TData = Awaited<ReturnType<typeof get2>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get2>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof get2>>,
          TError,
          Awaited<ReturnType<typeof get2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGet2<
  TData = Awaited<ReturnType<typeof get2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get2>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof get2>>,
          TError,
          Awaited<ReturnType<typeof get2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGet2<
  TData = Awaited<ReturnType<typeof get2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get2>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Returns all country-phone-prefixes list
 */

export function useGet2<
  TData = Awaited<ReturnType<typeof get2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get2>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGet2QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Method to find all the countries
 */
export const getAllCountries2 = (signal?: AbortSignal) => {
  return customInstance<Country[]>({
    url: `/countries`,
    method: "GET",
    signal,
  });
};

export const getGetAllCountries2QueryKey = () => {
  return [`/countries`] as const;
};

export const getGetAllCountries2QueryOptions = <
  TData = Awaited<ReturnType<typeof getAllCountries2>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllCountries2>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllCountries2QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllCountries2>>
  > = ({ signal }) => getAllCountries2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllCountries2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllCountries2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllCountries2>>
>;
export type GetAllCountries2QueryError = void;

export function useGetAllCountries2<
  TData = Awaited<ReturnType<typeof getAllCountries2>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllCountries2>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCountries2>>,
          TError,
          Awaited<ReturnType<typeof getAllCountries2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllCountries2<
  TData = Awaited<ReturnType<typeof getAllCountries2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllCountries2>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCountries2>>,
          TError,
          Awaited<ReturnType<typeof getAllCountries2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllCountries2<
  TData = Awaited<ReturnType<typeof getAllCountries2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllCountries2>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Method to find all the countries
 */

export function useGetAllCountries2<
  TData = Awaited<ReturnType<typeof getAllCountries2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllCountries2>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllCountries2QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Method to find a country by the caller IP
 */
export const getCountryByIp1 = (signal?: AbortSignal) => {
  return customInstance<Country>({
    url: `/countries/current`,
    method: "GET",
    signal,
  });
};

export const getGetCountryByIp1QueryKey = () => {
  return [`/countries/current`] as const;
};

export const getGetCountryByIp1QueryOptions = <
  TData = Awaited<ReturnType<typeof getCountryByIp1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCountryByIp1>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCountryByIp1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCountryByIp1>>> = ({
    signal,
  }) => getCountryByIp1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCountryByIp1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCountryByIp1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getCountryByIp1>>
>;
export type GetCountryByIp1QueryError = void;

export function useGetCountryByIp1<
  TData = Awaited<ReturnType<typeof getCountryByIp1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCountryByIp1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCountryByIp1>>,
          TError,
          Awaited<ReturnType<typeof getCountryByIp1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCountryByIp1<
  TData = Awaited<ReturnType<typeof getCountryByIp1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCountryByIp1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCountryByIp1>>,
          TError,
          Awaited<ReturnType<typeof getCountryByIp1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCountryByIp1<
  TData = Awaited<ReturnType<typeof getCountryByIp1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCountryByIp1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Method to find a country by the caller IP
 */

export function useGetCountryByIp1<
  TData = Awaited<ReturnType<typeof getCountryByIp1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCountryByIp1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCountryByIp1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Retrieves the list of all exchange available in application
 */
export const getCurrencies1 = (signal?: AbortSignal) => {
  return customInstance<Currency[]>({
    url: `/currencies`,
    method: "GET",
    signal,
  });
};

export const getGetCurrencies1QueryKey = () => {
  return [`/currencies`] as const;
};

export const getGetCurrencies1QueryOptions = <
  TData = Awaited<ReturnType<typeof getCurrencies1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrencies1>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCurrencies1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrencies1>>> = ({
    signal,
  }) => getCurrencies1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCurrencies1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCurrencies1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getCurrencies1>>
>;
export type GetCurrencies1QueryError = void;

export function useGetCurrencies1<
  TData = Awaited<ReturnType<typeof getCurrencies1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCurrencies1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrencies1>>,
          TError,
          Awaited<ReturnType<typeof getCurrencies1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCurrencies1<
  TData = Awaited<ReturnType<typeof getCurrencies1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCurrencies1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrencies1>>,
          TError,
          Awaited<ReturnType<typeof getCurrencies1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCurrencies1<
  TData = Awaited<ReturnType<typeof getCurrencies1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCurrencies1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieves the list of all exchange available in application
 */

export function useGetCurrencies1<
  TData = Awaited<ReturnType<typeof getCurrencies1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCurrencies1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCurrencies1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns a map of currency exchange rates between different currencies
 * @summary Method to find all the exchange rates
 */
export const findExchangeRates1 = (signal?: AbortSignal) => {
  return customInstance<ExchangeRateMap>({
    url: `/exchange-rates`,
    method: "GET",
    signal,
  });
};

export const getFindExchangeRates1QueryKey = () => {
  return [`/exchange-rates`] as const;
};

export const getFindExchangeRates1QueryOptions = <
  TData = Awaited<ReturnType<typeof findExchangeRates1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof findExchangeRates1>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindExchangeRates1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findExchangeRates1>>
  > = ({ signal }) => findExchangeRates1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findExchangeRates1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindExchangeRates1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findExchangeRates1>>
>;
export type FindExchangeRates1QueryError = void;

export function useFindExchangeRates1<
  TData = Awaited<ReturnType<typeof findExchangeRates1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findExchangeRates1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findExchangeRates1>>,
          TError,
          Awaited<ReturnType<typeof findExchangeRates1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindExchangeRates1<
  TData = Awaited<ReturnType<typeof findExchangeRates1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findExchangeRates1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findExchangeRates1>>,
          TError,
          Awaited<ReturnType<typeof findExchangeRates1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindExchangeRates1<
  TData = Awaited<ReturnType<typeof findExchangeRates1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findExchangeRates1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Method to find all the exchange rates
 */

export function useFindExchangeRates1<
  TData = Awaited<ReturnType<typeof findExchangeRates1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findExchangeRates1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindExchangeRates1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
 * @summary Retrieves geolocation information
 */
export const getGeoLocationsByLatLng1 = (
  params?: GetGeoLocationsByLatLng1Params,
  signal?: AbortSignal,
) => {
  return customInstance<GeoPlace>({
    url: `/geo-locations`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetGeoLocationsByLatLng1QueryKey = (
  params?: GetGeoLocationsByLatLng1Params,
) => {
  return [`/geo-locations`, ...(params ? [params] : [])] as const;
};

export const getGetGeoLocationsByLatLng1QueryOptions = <
  TData = Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
  TError = void,
>(
  params?: GetGeoLocationsByLatLng1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGeoLocationsByLatLng1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>
  > = ({ signal }) => getGeoLocationsByLatLng1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGeoLocationsByLatLng1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>
>;
export type GetGeoLocationsByLatLng1QueryError = void;

export function useGetGeoLocationsByLatLng1<
  TData = Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
  TError = void,
>(
  params: undefined | GetGeoLocationsByLatLng1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
          TError,
          Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGeoLocationsByLatLng1<
  TData = Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
  TError = void,
>(
  params?: GetGeoLocationsByLatLng1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
          TError,
          Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGeoLocationsByLatLng1<
  TData = Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
  TError = void,
>(
  params?: GetGeoLocationsByLatLng1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieves geolocation information
 */

export function useGetGeoLocationsByLatLng1<
  TData = Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
  TError = void,
>(
  params?: GetGeoLocationsByLatLng1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGeoLocationsByLatLng1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGeoLocationsByLatLng1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns a list of all supported languages in the system
 * @summary Get all available languages
 */
export const getAllLanguages1 = (signal?: AbortSignal) => {
  return customInstance<Language[]>({
    url: `/languages`,
    method: "GET",
    signal,
  });
};

export const getGetAllLanguages1QueryKey = () => {
  return [`/languages`] as const;
};

export const getGetAllLanguages1QueryOptions = <
  TData = Awaited<ReturnType<typeof getAllLanguages1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllLanguages1>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllLanguages1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllLanguages1>>
  > = ({ signal }) => getAllLanguages1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllLanguages1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllLanguages1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllLanguages1>>
>;
export type GetAllLanguages1QueryError = void;

export function useGetAllLanguages1<
  TData = Awaited<ReturnType<typeof getAllLanguages1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllLanguages1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllLanguages1>>,
          TError,
          Awaited<ReturnType<typeof getAllLanguages1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllLanguages1<
  TData = Awaited<ReturnType<typeof getAllLanguages1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllLanguages1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllLanguages1>>,
          TError,
          Awaited<ReturnType<typeof getAllLanguages1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllLanguages1<
  TData = Awaited<ReturnType<typeof getAllLanguages1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllLanguages1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all available languages
 */

export function useGetAllLanguages1<
  TData = Awaited<ReturnType<typeof getAllLanguages1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllLanguages1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllLanguages1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Removes a locale entry identified by its pnemonic code along with all its translations
 * @summary Delete a locale entry with all translations related
 */
export const delete1 = (pnemonic: string) => {
  return customInstance<string>({
    url: `/locales/${pnemonic}`,
    method: "DELETE",
  });
};

export const getDelete1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof delete1>>,
    TError,
    { pnemonic: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof delete1>>,
  TError,
  { pnemonic: string },
  TContext
> => {
  const mutationKey = ["delete1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof delete1>>,
    { pnemonic: string }
  > = (props) => {
    const { pnemonic } = props ?? {};

    return delete1(pnemonic);
  };

  return { mutationFn, ...mutationOptions };
};

export type Delete1MutationResult = NonNullable<
  Awaited<ReturnType<typeof delete1>>
>;

export type Delete1MutationError = void;

/**
 * @summary Delete a locale entry with all translations related
 */
export const useDelete1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof delete1>>,
      TError,
      { pnemonic: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof delete1>>,
  TError,
  { pnemonic: string },
  TContext
> => {
  const mutationOptions = getDelete1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves the complete list of available locales in the system
 * @summary Returns all language list locale entries
 */
export const find3 = (signal?: AbortSignal) => {
  return customInstance<LocaleSet[]>({
    url: `/locales`,
    method: "GET",
    signal,
  });
};

export const getFind3QueryKey = () => {
  return [`/locales`] as const;
};

export const getFind3QueryOptions = <
  TData = Awaited<ReturnType<typeof find3>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof find3>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFind3QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof find3>>> = ({
    signal,
  }) => find3(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof find3>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type Find3QueryResult = NonNullable<Awaited<ReturnType<typeof find3>>>;
export type Find3QueryError = void;

export function useFind3<
  TData = Awaited<ReturnType<typeof find3>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find3>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof find3>>,
          TError,
          Awaited<ReturnType<typeof find3>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFind3<
  TData = Awaited<ReturnType<typeof find3>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find3>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof find3>>,
          TError,
          Awaited<ReturnType<typeof find3>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFind3<
  TData = Awaited<ReturnType<typeof find3>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find3>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Returns all language list locale entries
 */

export function useFind3<
  TData = Awaited<ReturnType<typeof find3>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find3>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFind3QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves the locale translations in the specified language
 * @summary Returns locale language list
 */
export const getLanguages1 = (
  params?: GetLanguages1Params,
  signal?: AbortSignal,
) => {
  return customInstance<GetLanguages1200>({
    url: `/locales/translations`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetLanguages1QueryKey = (params?: GetLanguages1Params) => {
  return [`/locales/translations`, ...(params ? [params] : [])] as const;
};

export const getGetLanguages1QueryOptions = <
  TData = Awaited<ReturnType<typeof getLanguages1>>,
  TError = void,
>(
  params?: GetLanguages1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLanguages1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLanguages1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLanguages1>>> = ({
    signal,
  }) => getLanguages1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLanguages1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLanguages1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getLanguages1>>
>;
export type GetLanguages1QueryError = void;

export function useGetLanguages1<
  TData = Awaited<ReturnType<typeof getLanguages1>>,
  TError = void,
>(
  params: undefined | GetLanguages1Params,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLanguages1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLanguages1>>,
          TError,
          Awaited<ReturnType<typeof getLanguages1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLanguages1<
  TData = Awaited<ReturnType<typeof getLanguages1>>,
  TError = void,
>(
  params?: GetLanguages1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLanguages1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLanguages1>>,
          TError,
          Awaited<ReturnType<typeof getLanguages1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetLanguages1<
  TData = Awaited<ReturnType<typeof getLanguages1>>,
  TError = void,
>(
  params?: GetLanguages1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLanguages1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Returns locale language list
 */

export function useGetLanguages1<
  TData = Awaited<ReturnType<typeof getLanguages1>>,
  TError = void,
>(
  params?: GetLanguages1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getLanguages1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetLanguages1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Translate the provided text to the specified target language
 * @summary Get text translation to a target language
 */
export const translateText1 = (
  params?: TranslateText1Params,
  signal?: AbortSignal,
) => {
  return customInstance<TextTranslation>({
    url: `/text-translations`,
    method: "GET",
    params,
    signal,
  });
};

export const getTranslateText1QueryKey = (params?: TranslateText1Params) => {
  return [`/text-translations`, ...(params ? [params] : [])] as const;
};

export const getTranslateText1QueryOptions = <
  TData = Awaited<ReturnType<typeof translateText1>>,
  TError = void,
>(
  params?: TranslateText1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof translateText1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTranslateText1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof translateText1>>> = ({
    signal,
  }) => translateText1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof translateText1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TranslateText1QueryResult = NonNullable<
  Awaited<ReturnType<typeof translateText1>>
>;
export type TranslateText1QueryError = void;

export function useTranslateText1<
  TData = Awaited<ReturnType<typeof translateText1>>,
  TError = void,
>(
  params: undefined | TranslateText1Params,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof translateText1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof translateText1>>,
          TError,
          Awaited<ReturnType<typeof translateText1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTranslateText1<
  TData = Awaited<ReturnType<typeof translateText1>>,
  TError = void,
>(
  params?: TranslateText1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof translateText1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof translateText1>>,
          TError,
          Awaited<ReturnType<typeof translateText1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useTranslateText1<
  TData = Awaited<ReturnType<typeof translateText1>>,
  TError = void,
>(
  params?: TranslateText1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof translateText1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get text translation to a target language
 */

export function useTranslateText1<
  TData = Awaited<ReturnType<typeof translateText1>>,
  TError = void,
>(
  params?: TranslateText1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof translateText1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getTranslateText1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
 * @summary Manually trigger Kyero exports to S3
 */
export const triggerKyeroExport1 = (signal?: AbortSignal) => {
  return customInstance<string>({
    url: `/property-bulk-download/trigger-kyero-export`,
    method: "POST",
    signal,
  });
};

export const getTriggerKyeroExport1MutationOptions = <
  TError = string,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof triggerKyeroExport1>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof triggerKyeroExport1>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["triggerKyeroExport1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof triggerKyeroExport1>>,
    void
  > = () => {
    return triggerKyeroExport1();
  };

  return { mutationFn, ...mutationOptions };
};

export type TriggerKyeroExport1MutationResult = NonNullable<
  Awaited<ReturnType<typeof triggerKyeroExport1>>
>;

export type TriggerKyeroExport1MutationError = string;

/**
 * @summary Manually trigger Kyero exports to S3
 */
export const useTriggerKyeroExport1 = <TError = string, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof triggerKyeroExport1>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof triggerKyeroExport1>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getTriggerKyeroExport1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Generates and returns property data in XML format for a specific user and format type.
 * @summary Get property XML for specific user
 */
export const xml1 = (
  userId: string,
  xmlFormat: string,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/property-bulk-download/${userId}/${xmlFormat}.xml`,
    method: "GET",
    signal,
  });
};

export const getXml1QueryKey = (userId: string, xmlFormat: string) => {
  return [`/property-bulk-download/${userId}/${xmlFormat}.xml`] as const;
};

export const getXml1QueryOptions = <
  TData = Awaited<ReturnType<typeof xml1>>,
  TError = string,
>(
  userId: string,
  xmlFormat: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof xml1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getXml1QueryKey(userId, xmlFormat);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof xml1>>> = ({
    signal,
  }) => xml1(userId, xmlFormat, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(userId && xmlFormat),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof xml1>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type Xml1QueryResult = NonNullable<Awaited<ReturnType<typeof xml1>>>;
export type Xml1QueryError = string;

export function useXml1<
  TData = Awaited<ReturnType<typeof xml1>>,
  TError = string,
>(
  userId: string,
  xmlFormat: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof xml1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof xml1>>,
          TError,
          Awaited<ReturnType<typeof xml1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useXml1<
  TData = Awaited<ReturnType<typeof xml1>>,
  TError = string,
>(
  userId: string,
  xmlFormat: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof xml1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof xml1>>,
          TError,
          Awaited<ReturnType<typeof xml1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useXml1<
  TData = Awaited<ReturnType<typeof xml1>>,
  TError = string,
>(
  userId: string,
  xmlFormat: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof xml1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get property XML for specific user
 */

export function useXml1<
  TData = Awaited<ReturnType<typeof xml1>>,
  TError = string,
>(
  userId: string,
  xmlFormat: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof xml1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getXml1QueryOptions(userId, xmlFormat, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
 * @deprecated
 * @summary Redirect to XML file (Deprecated)
 */
export const xmlRedirect1 = (
  userId: string,
  xmlFormat: string,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/property-bulk-download/${userId}/${xmlFormat}.xml.redirect`,
    method: "GET",
    signal,
  });
};

export const getXmlRedirect1QueryKey = (userId: string, xmlFormat: string) => {
  return [
    `/property-bulk-download/${userId}/${xmlFormat}.xml.redirect`,
  ] as const;
};

export const getXmlRedirect1QueryOptions = <
  TData = Awaited<ReturnType<typeof xmlRedirect1>>,
  TError = void | string,
>(
  userId: string,
  xmlFormat: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof xmlRedirect1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getXmlRedirect1QueryKey(userId, xmlFormat);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof xmlRedirect1>>> = ({
    signal,
  }) => xmlRedirect1(userId, xmlFormat, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(userId && xmlFormat),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof xmlRedirect1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type XmlRedirect1QueryResult = NonNullable<
  Awaited<ReturnType<typeof xmlRedirect1>>
>;
export type XmlRedirect1QueryError = void | string;

export function useXmlRedirect1<
  TData = Awaited<ReturnType<typeof xmlRedirect1>>,
  TError = void | string,
>(
  userId: string,
  xmlFormat: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof xmlRedirect1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof xmlRedirect1>>,
          TError,
          Awaited<ReturnType<typeof xmlRedirect1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useXmlRedirect1<
  TData = Awaited<ReturnType<typeof xmlRedirect1>>,
  TError = void | string,
>(
  userId: string,
  xmlFormat: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof xmlRedirect1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof xmlRedirect1>>,
          TError,
          Awaited<ReturnType<typeof xmlRedirect1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useXmlRedirect1<
  TData = Awaited<ReturnType<typeof xmlRedirect1>>,
  TError = void | string,
>(
  userId: string,
  xmlFormat: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof xmlRedirect1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @deprecated
 * @summary Redirect to XML file (Deprecated)
 */

export function useXmlRedirect1<
  TData = Awaited<ReturnType<typeof xmlRedirect1>>,
  TError = void | string,
>(
  userId: string,
  xmlFormat: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof xmlRedirect1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getXmlRedirect1QueryOptions(userId, xmlFormat, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get the list of supported file formats for bulk upload
 * @summary Get available formats
 */
export const getFormats1 = (signal?: AbortSignal) => {
  return customInstance<string[]>({
    url: `/property-bulk-uploads/formats`,
    method: "GET",
    signal,
  });
};

export const getGetFormats1QueryKey = () => {
  return [`/property-bulk-uploads/formats`] as const;
};

export const getGetFormats1QueryOptions = <
  TData = Awaited<ReturnType<typeof getFormats1>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFormats1>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFormats1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFormats1>>> = ({
    signal,
  }) => getFormats1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFormats1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFormats1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getFormats1>>
>;
export type GetFormats1QueryError = unknown;

export function useGetFormats1<
  TData = Awaited<ReturnType<typeof getFormats1>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFormats1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFormats1>>,
          TError,
          Awaited<ReturnType<typeof getFormats1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFormats1<
  TData = Awaited<ReturnType<typeof getFormats1>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFormats1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFormats1>>,
          TError,
          Awaited<ReturnType<typeof getFormats1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFormats1<
  TData = Awaited<ReturnType<typeof getFormats1>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFormats1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get available formats
 */

export function useGetFormats1<
  TData = Awaited<ReturnType<typeof getFormats1>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFormats1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFormats1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Upload properties using Kyero format with XML content in the request body
 * @summary Upload Kyero properties with XML in request body
 */
export const uploadKyeroProperties2 = (
  uploadKyeroProperties2Body: string,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/property-bulk-uploads/in-body`,
    method: "POST",
    headers: { "Content-Type": "application/xml" },
    data: uploadKyeroProperties2Body,
    signal,
  });
};

export const getUploadKyeroProperties2MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadKyeroProperties2>>,
    TError,
    { data: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadKyeroProperties2>>,
  TError,
  { data: string },
  TContext
> => {
  const mutationKey = ["uploadKyeroProperties2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadKyeroProperties2>>,
    { data: string }
  > = (props) => {
    const { data } = props ?? {};

    return uploadKyeroProperties2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadKyeroProperties2MutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadKyeroProperties2>>
>;
export type UploadKyeroProperties2MutationBody = string;
export type UploadKyeroProperties2MutationError = unknown;

/**
 * @summary Upload Kyero properties with XML in request body
 */
export const useUploadKyeroProperties2 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadKyeroProperties2>>,
      TError,
      { data: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadKyeroProperties2>>,
  TError,
  { data: string },
  TContext
> => {
  const mutationOptions = getUploadKyeroProperties2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Upload properties in Kyero format by providing a URL to an XML file
 * @summary Upload Kyero properties from URL
 */
export const uploadKyeroPropertiesFromUrl1 = (
  xmlUrl: XmlUrl,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/property-bulk-uploads/in-url`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: xmlUrl,
    signal,
  });
};

export const getUploadKyeroPropertiesFromUrl1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadKyeroPropertiesFromUrl1>>,
    TError,
    { data: XmlUrl },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadKyeroPropertiesFromUrl1>>,
  TError,
  { data: XmlUrl },
  TContext
> => {
  const mutationKey = ["uploadKyeroPropertiesFromUrl1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadKyeroPropertiesFromUrl1>>,
    { data: XmlUrl }
  > = (props) => {
    const { data } = props ?? {};

    return uploadKyeroPropertiesFromUrl1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadKyeroPropertiesFromUrl1MutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadKyeroPropertiesFromUrl1>>
>;
export type UploadKyeroPropertiesFromUrl1MutationBody = XmlUrl;
export type UploadKyeroPropertiesFromUrl1MutationError = unknown;

/**
 * @summary Upload Kyero properties from URL
 */
export const useUploadKyeroPropertiesFromUrl1 = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadKyeroPropertiesFromUrl1>>,
      TError,
      { data: XmlUrl },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadKyeroPropertiesFromUrl1>>,
  TError,
  { data: XmlUrl },
  TContext
> => {
  const mutationOptions =
    getUploadKyeroPropertiesFromUrl1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Upload properties with XML content in the request body using the specified format
 * @summary Upload properties in specified format with XML in request body
 */
export const uploadProperties1 = (
  format: "kyero" | "wasico" | "xml2u" | "hallocasa",
  uploadProperties1Body: string,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/property-bulk-uploads/${format}/in-body`,
    method: "POST",
    headers: { "Content-Type": "application/xml" },
    data: uploadProperties1Body,
    signal,
  });
};

export const getUploadProperties1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadProperties1>>,
    TError,
    { format: "kyero" | "wasico" | "xml2u" | "hallocasa"; data: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadProperties1>>,
  TError,
  { format: "kyero" | "wasico" | "xml2u" | "hallocasa"; data: string },
  TContext
> => {
  const mutationKey = ["uploadProperties1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadProperties1>>,
    { format: "kyero" | "wasico" | "xml2u" | "hallocasa"; data: string }
  > = (props) => {
    const { format, data } = props ?? {};

    return uploadProperties1(format, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadProperties1MutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadProperties1>>
>;
export type UploadProperties1MutationBody = string;
export type UploadProperties1MutationError = unknown;

/**
 * @summary Upload properties in specified format with XML in request body
 */
export const useUploadProperties1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadProperties1>>,
      TError,
      { format: "kyero" | "wasico" | "xml2u" | "hallocasa"; data: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadProperties1>>,
  TError,
  { format: "kyero" | "wasico" | "xml2u" | "hallocasa"; data: string },
  TContext
> => {
  const mutationOptions = getUploadProperties1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Upload properties in the specified format by providing a URL to an XML file
 * @summary Upload properties in specified format from URL
 */
export const uploadPropertiesFromUrl1 = (
  format: "kyero" | "wasico" | "xml2u" | "hallocasa",
  xmlUrl: XmlUrl,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/property-bulk-uploads/${format}/in-url`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: xmlUrl,
    signal,
  });
};

export const getUploadPropertiesFromUrl1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadPropertiesFromUrl1>>,
    TError,
    { format: "kyero" | "wasico" | "xml2u" | "hallocasa"; data: XmlUrl },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadPropertiesFromUrl1>>,
  TError,
  { format: "kyero" | "wasico" | "xml2u" | "hallocasa"; data: XmlUrl },
  TContext
> => {
  const mutationKey = ["uploadPropertiesFromUrl1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadPropertiesFromUrl1>>,
    { format: "kyero" | "wasico" | "xml2u" | "hallocasa"; data: XmlUrl }
  > = (props) => {
    const { format, data } = props ?? {};

    return uploadPropertiesFromUrl1(format, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadPropertiesFromUrl1MutationResult = NonNullable<
  Awaited<ReturnType<typeof uploadPropertiesFromUrl1>>
>;
export type UploadPropertiesFromUrl1MutationBody = XmlUrl;
export type UploadPropertiesFromUrl1MutationError = unknown;

/**
 * @summary Upload properties in specified format from URL
 */
export const useUploadPropertiesFromUrl1 = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadPropertiesFromUrl1>>,
      TError,
      { format: "kyero" | "wasico" | "xml2u" | "hallocasa"; data: XmlUrl },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadPropertiesFromUrl1>>,
  TError,
  { format: "kyero" | "wasico" | "xml2u" | "hallocasa"; data: XmlUrl },
  TContext
> => {
  const mutationOptions = getUploadPropertiesFromUrl1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Exports property data to Facebook Marketplace format within the specified date range
 * @summary Export properties to Facebook Marketplace
 */
export const uploadKyeroProperties = (
  params: UploadKyeroPropertiesParams,
  signal?: AbortSignal,
) => {
  return customInstance<FBPropertyDto[]>({
    url: `/facebook-properties`,
    method: "GET",
    params,
    signal,
  });
};

export const getUploadKyeroPropertiesQueryKey = (
  params: UploadKyeroPropertiesParams,
) => {
  return [`/facebook-properties`, ...(params ? [params] : [])] as const;
};

export const getUploadKyeroPropertiesQueryOptions = <
  TData = Awaited<ReturnType<typeof uploadKyeroProperties>>,
  TError = unknown,
>(
  params: UploadKyeroPropertiesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof uploadKyeroProperties>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUploadKyeroPropertiesQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof uploadKyeroProperties>>
  > = ({ signal }) => uploadKyeroProperties(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof uploadKyeroProperties>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UploadKyeroPropertiesQueryResult = NonNullable<
  Awaited<ReturnType<typeof uploadKyeroProperties>>
>;
export type UploadKyeroPropertiesQueryError = unknown;

export function useUploadKyeroProperties<
  TData = Awaited<ReturnType<typeof uploadKyeroProperties>>,
  TError = unknown,
>(
  params: UploadKyeroPropertiesParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof uploadKyeroProperties>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof uploadKyeroProperties>>,
          TError,
          Awaited<ReturnType<typeof uploadKyeroProperties>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUploadKyeroProperties<
  TData = Awaited<ReturnType<typeof uploadKyeroProperties>>,
  TError = unknown,
>(
  params: UploadKyeroPropertiesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof uploadKyeroProperties>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof uploadKyeroProperties>>,
          TError,
          Awaited<ReturnType<typeof uploadKyeroProperties>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useUploadKyeroProperties<
  TData = Awaited<ReturnType<typeof uploadKyeroProperties>>,
  TError = unknown,
>(
  params: UploadKyeroPropertiesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof uploadKyeroProperties>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Export properties to Facebook Marketplace
 */

export function useUploadKyeroProperties<
  TData = Awaited<ReturnType<typeof uploadKyeroProperties>>,
  TError = unknown,
>(
  params: UploadKyeroPropertiesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof uploadKyeroProperties>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getUploadKyeroPropertiesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * For Group Owners, this list will return removed, left, invited and requested members as well
 * @summary Show all members of Group
 */
export const getGroupMembers1 = (
  groupId: string,
  params?: GetGroupMembers1Params,
  signal?: AbortSignal,
) => {
  return customInstance<BaseFilterResult>({
    url: `/groups/${groupId}/members`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetGroupMembers1QueryKey = (
  groupId: string,
  params?: GetGroupMembers1Params,
) => {
  return [`/groups/${groupId}/members`, ...(params ? [params] : [])] as const;
};

export const getGetGroupMembers1QueryOptions = <
  TData = Awaited<ReturnType<typeof getGroupMembers1>>,
  TError = void,
>(
  groupId: string,
  params?: GetGroupMembers1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupMembers1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGroupMembers1QueryKey(groupId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGroupMembers1>>
  > = ({ signal }) => getGroupMembers1(groupId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!groupId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGroupMembers1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroupMembers1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroupMembers1>>
>;
export type GetGroupMembers1QueryError = void;

export function useGetGroupMembers1<
  TData = Awaited<ReturnType<typeof getGroupMembers1>>,
  TError = void,
>(
  groupId: string,
  params: undefined | GetGroupMembers1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupMembers1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupMembers1>>,
          TError,
          Awaited<ReturnType<typeof getGroupMembers1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupMembers1<
  TData = Awaited<ReturnType<typeof getGroupMembers1>>,
  TError = void,
>(
  groupId: string,
  params?: GetGroupMembers1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupMembers1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupMembers1>>,
          TError,
          Awaited<ReturnType<typeof getGroupMembers1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupMembers1<
  TData = Awaited<ReturnType<typeof getGroupMembers1>>,
  TError = void,
>(
  groupId: string,
  params?: GetGroupMembers1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupMembers1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Show all members of Group
 */

export function useGetGroupMembers1<
  TData = Awaited<ReturnType<typeof getGroupMembers1>>,
  TError = void,
>(
  groupId: string,
  params?: GetGroupMembers1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupMembers1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroupMembers1QueryOptions(
    groupId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Accept Group Invitation
 */
export const groupInvite2 = (groupId: string, signal?: AbortSignal) => {
  return customInstance<GroupMember>({
    url: `/groups/${groupId}/accept-invite`,
    method: "POST",
    signal,
  });
};

export const getGroupInvite2MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof groupInvite2>>,
    TError,
    { groupId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof groupInvite2>>,
  TError,
  { groupId: string },
  TContext
> => {
  const mutationKey = ["groupInvite2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof groupInvite2>>,
    { groupId: string }
  > = (props) => {
    const { groupId } = props ?? {};

    return groupInvite2(groupId);
  };

  return { mutationFn, ...mutationOptions };
};

export type GroupInvite2MutationResult = NonNullable<
  Awaited<ReturnType<typeof groupInvite2>>
>;

export type GroupInvite2MutationError = void;

/**
 * @summary Accept Group Invitation
 */
export const useGroupInvite2 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof groupInvite2>>,
      TError,
      { groupId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof groupInvite2>>,
  TError,
  { groupId: string },
  TContext
> => {
  const mutationOptions = getGroupInvite2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Request Invitation to Group
 */
export const groupInvite = (
  groupId: string,
  params?: GroupInviteParams,
  signal?: AbortSignal,
) => {
  return customInstance<GroupMember[]>({
    url: `/groups/${groupId}/invite`,
    method: "POST",
    params,
    signal,
  });
};

export const getGroupInviteMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof groupInvite>>,
    TError,
    { groupId: string; params?: GroupInviteParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof groupInvite>>,
  TError,
  { groupId: string; params?: GroupInviteParams },
  TContext
> => {
  const mutationKey = ["groupInvite"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof groupInvite>>,
    { groupId: string; params?: GroupInviteParams }
  > = (props) => {
    const { groupId, params } = props ?? {};

    return groupInvite(groupId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type GroupInviteMutationResult = NonNullable<
  Awaited<ReturnType<typeof groupInvite>>
>;

export type GroupInviteMutationError = void;

/**
 * @summary Request Invitation to Group
 */
export const useGroupInvite = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof groupInvite>>,
      TError,
      { groupId: string; params?: GroupInviteParams },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof groupInvite>>,
  TError,
  { groupId: string; params?: GroupInviteParams },
  TContext
> => {
  const mutationOptions = getGroupInviteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Leave Group
 */
export const groupLeave1 = (groupId: string, signal?: AbortSignal) => {
  return customInstance<GroupMember>({
    url: `/groups/${groupId}/leave`,
    method: "POST",
    signal,
  });
};

export const getGroupLeave1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof groupLeave1>>,
    TError,
    { groupId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof groupLeave1>>,
  TError,
  { groupId: string },
  TContext
> => {
  const mutationKey = ["groupLeave1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof groupLeave1>>,
    { groupId: string }
  > = (props) => {
    const { groupId } = props ?? {};

    return groupLeave1(groupId);
  };

  return { mutationFn, ...mutationOptions };
};

export type GroupLeave1MutationResult = NonNullable<
  Awaited<ReturnType<typeof groupLeave1>>
>;

export type GroupLeave1MutationError = void;

/**
 * @summary Leave Group
 */
export const useGroupLeave1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof groupLeave1>>,
      TError,
      { groupId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof groupLeave1>>,
  TError,
  { groupId: string },
  TContext
> => {
  const mutationOptions = getGroupLeave1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Request Admission to Group
 */
export const groupRequest1 = (groupId: string, signal?: AbortSignal) => {
  return customInstance<GroupMember>({
    url: `/groups/${groupId}/request`,
    method: "POST",
    signal,
  });
};

export const getGroupRequest1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof groupRequest1>>,
    TError,
    { groupId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof groupRequest1>>,
  TError,
  { groupId: string },
  TContext
> => {
  const mutationKey = ["groupRequest1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof groupRequest1>>,
    { groupId: string }
  > = (props) => {
    const { groupId } = props ?? {};

    return groupRequest1(groupId);
  };

  return { mutationFn, ...mutationOptions };
};

export type GroupRequest1MutationResult = NonNullable<
  Awaited<ReturnType<typeof groupRequest1>>
>;

export type GroupRequest1MutationError = void;

/**
 * @summary Request Admission to Group
 */
export const useGroupRequest1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof groupRequest1>>,
      TError,
      { groupId: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof groupRequest1>>,
  TError,
  { groupId: string },
  TContext
> => {
  const mutationOptions = getGroupRequest1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
 * @summary Update the group member status from groupId supplied
 */
export const updateGroupMembershipStatus1 = (
  groupId: string,
  params?: UpdateGroupMembershipStatus1Params,
  signal?: AbortSignal,
) => {
  return customInstance<GroupMember[]>({
    url: `/groups/${groupId}/member-status`,
    method: "POST",
    params,
    signal,
  });
};

export const getUpdateGroupMembershipStatus1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateGroupMembershipStatus1>>,
    TError,
    { groupId: string; params?: UpdateGroupMembershipStatus1Params },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateGroupMembershipStatus1>>,
  TError,
  { groupId: string; params?: UpdateGroupMembershipStatus1Params },
  TContext
> => {
  const mutationKey = ["updateGroupMembershipStatus1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateGroupMembershipStatus1>>,
    { groupId: string; params?: UpdateGroupMembershipStatus1Params }
  > = (props) => {
    const { groupId, params } = props ?? {};

    return updateGroupMembershipStatus1(groupId, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateGroupMembershipStatus1MutationResult = NonNullable<
  Awaited<ReturnType<typeof updateGroupMembershipStatus1>>
>;

export type UpdateGroupMembershipStatus1MutationError = void;

/**
 * @summary Update the group member status from groupId supplied
 */
export const useUpdateGroupMembershipStatus1 = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateGroupMembershipStatus1>>,
      TError,
      { groupId: string; params?: UpdateGroupMembershipStatus1Params },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateGroupMembershipStatus1>>,
  TError,
  { groupId: string; params?: UpdateGroupMembershipStatus1Params },
  TContext
> => {
  const mutationOptions =
    getUpdateGroupMembershipStatus1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * This process is reversible
 * @summary Archive the group with id supplied
 */
export const archiveGroup1 = (id: string, signal?: AbortSignal) => {
  return customInstance<string>({
    url: `/groups/${id}/archive`,
    method: "POST",
    signal,
  });
};

export const getArchiveGroup1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof archiveGroup1>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof archiveGroup1>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["archiveGroup1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof archiveGroup1>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return archiveGroup1(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type ArchiveGroup1MutationResult = NonNullable<
  Awaited<ReturnType<typeof archiveGroup1>>
>;

export type ArchiveGroup1MutationError = void;

/**
 * @summary Archive the group with id supplied
 */
export const useArchiveGroup1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof archiveGroup1>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof archiveGroup1>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getArchiveGroup1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * This process is reversible
 * @summary Deactivate the group with id supplied
 */
export const deactivateGroup1 = (id: string, signal?: AbortSignal) => {
  return customInstance<string>({
    url: `/groups/${id}/deactivate`,
    method: "POST",
    signal,
  });
};

export const getDeactivateGroup1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deactivateGroup1>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deactivateGroup1>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deactivateGroup1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deactivateGroup1>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deactivateGroup1(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeactivateGroup1MutationResult = NonNullable<
  Awaited<ReturnType<typeof deactivateGroup1>>
>;

export type DeactivateGroup1MutationError = void;

/**
 * @summary Deactivate the group with id supplied
 */
export const useDeactivateGroup1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deactivateGroup1>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deactivateGroup1>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeactivateGroup1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * This process is not reversible
 * @summary Delete the group with id supplied
 */
export const deleteGroup1 = (id: string) => {
  return customInstance<unknown>({ url: `/groups/${id}`, method: "DELETE" });
};

export const getDeleteGroup1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteGroup1>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteGroup1>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteGroup1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteGroup1>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteGroup1(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteGroup1MutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteGroup1>>
>;

export type DeleteGroup1MutationError = void;

/**
 * @summary Delete the group with id supplied
 */
export const useDeleteGroup1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteGroup1>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteGroup1>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteGroup1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Return the groups list with specified user id that user has archived
 */
export const findArchivedGroupsByUser1 = (
  params?: FindArchivedGroupsByUser1Params,
  signal?: AbortSignal,
) => {
  return customInstance<BaseFilterResult>({
    url: `/groups/archived`,
    method: "GET",
    params,
    signal,
  });
};

export const getFindArchivedGroupsByUser1QueryKey = (
  params?: FindArchivedGroupsByUser1Params,
) => {
  return [`/groups/archived`, ...(params ? [params] : [])] as const;
};

export const getFindArchivedGroupsByUser1QueryOptions = <
  TData = Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
  TError = void,
>(
  params?: FindArchivedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindArchivedGroupsByUser1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findArchivedGroupsByUser1>>
  > = ({ signal }) => findArchivedGroupsByUser1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindArchivedGroupsByUser1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findArchivedGroupsByUser1>>
>;
export type FindArchivedGroupsByUser1QueryError = void;

export function useFindArchivedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
  TError = void,
>(
  params: undefined | FindArchivedGroupsByUser1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findArchivedGroupsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindArchivedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
  TError = void,
>(
  params?: FindArchivedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findArchivedGroupsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindArchivedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
  TError = void,
>(
  params?: FindArchivedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the groups list with specified user id that user has archived
 */

export function useFindArchivedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
  TError = void,
>(
  params?: FindArchivedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findArchivedGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindArchivedGroupsByUser1QueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
 * @summary Return the group with specified id
 */
export const findGroup1 = (groupId: string, signal?: AbortSignal) => {
  return customInstance<Group>({
    url: `/groups/${groupId}`,
    method: "GET",
    signal,
  });
};

export const getFindGroup1QueryKey = (groupId: string) => {
  return [`/groups/${groupId}`] as const;
};

export const getFindGroup1QueryOptions = <
  TData = Awaited<ReturnType<typeof findGroup1>>,
  TError = void,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findGroup1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindGroup1QueryKey(groupId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findGroup1>>> = ({
    signal,
  }) => findGroup1(groupId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!groupId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findGroup1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindGroup1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findGroup1>>
>;
export type FindGroup1QueryError = void;

export function useFindGroup1<
  TData = Awaited<ReturnType<typeof findGroup1>>,
  TError = void,
>(
  groupId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findGroup1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findGroup1>>,
          TError,
          Awaited<ReturnType<typeof findGroup1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindGroup1<
  TData = Awaited<ReturnType<typeof findGroup1>>,
  TError = void,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findGroup1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findGroup1>>,
          TError,
          Awaited<ReturnType<typeof findGroup1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindGroup1<
  TData = Awaited<ReturnType<typeof findGroup1>>,
  TError = void,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findGroup1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the group with specified id
 */

export function useFindGroup1<
  TData = Awaited<ReturnType<typeof findGroup1>>,
  TError = void,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findGroup1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindGroup1QueryOptions(groupId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
 * @summary Return the group with specified id
 */
export const findGroupProperties1 = (groupId: string, signal?: AbortSignal) => {
  return customInstance<Property[]>({
    url: `/groups/${groupId}/properties`,
    method: "GET",
    signal,
  });
};

export const getFindGroupProperties1QueryKey = (groupId: string) => {
  return [`/groups/${groupId}/properties`] as const;
};

export const getFindGroupProperties1QueryOptions = <
  TData = Awaited<ReturnType<typeof findGroupProperties1>>,
  TError = void,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findGroupProperties1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindGroupProperties1QueryKey(groupId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findGroupProperties1>>
  > = ({ signal }) => findGroupProperties1(groupId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!groupId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findGroupProperties1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindGroupProperties1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findGroupProperties1>>
>;
export type FindGroupProperties1QueryError = void;

export function useFindGroupProperties1<
  TData = Awaited<ReturnType<typeof findGroupProperties1>>,
  TError = void,
>(
  groupId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findGroupProperties1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findGroupProperties1>>,
          TError,
          Awaited<ReturnType<typeof findGroupProperties1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindGroupProperties1<
  TData = Awaited<ReturnType<typeof findGroupProperties1>>,
  TError = void,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findGroupProperties1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findGroupProperties1>>,
          TError,
          Awaited<ReturnType<typeof findGroupProperties1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindGroupProperties1<
  TData = Awaited<ReturnType<typeof findGroupProperties1>>,
  TError = void,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findGroupProperties1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the group with specified id
 */

export function useFindGroupProperties1<
  TData = Awaited<ReturnType<typeof findGroupProperties1>>,
  TError = void,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findGroupProperties1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindGroupProperties1QueryOptions(groupId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
 * @summary Return the group with specified id
 */
export const findGroupPropertiesSearch1 = (
  groupId: string,
  propertyFilterCriteria: PropertyFilterCriteria,
  signal?: AbortSignal,
) => {
  return customInstance<BaseFilterResult>({
    url: `/groups/${groupId}/properties/search`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: propertyFilterCriteria,
    signal,
  });
};

export const getFindGroupPropertiesSearch1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof findGroupPropertiesSearch1>>,
    TError,
    { groupId: string; data: PropertyFilterCriteria },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof findGroupPropertiesSearch1>>,
  TError,
  { groupId: string; data: PropertyFilterCriteria },
  TContext
> => {
  const mutationKey = ["findGroupPropertiesSearch1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof findGroupPropertiesSearch1>>,
    { groupId: string; data: PropertyFilterCriteria }
  > = (props) => {
    const { groupId, data } = props ?? {};

    return findGroupPropertiesSearch1(groupId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type FindGroupPropertiesSearch1MutationResult = NonNullable<
  Awaited<ReturnType<typeof findGroupPropertiesSearch1>>
>;
export type FindGroupPropertiesSearch1MutationBody = PropertyFilterCriteria;
export type FindGroupPropertiesSearch1MutationError = void;

/**
 * @summary Return the group with specified id
 */
export const useFindGroupPropertiesSearch1 = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof findGroupPropertiesSearch1>>,
      TError,
      { groupId: string; data: PropertyFilterCriteria },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof findGroupPropertiesSearch1>>,
  TError,
  { groupId: string; data: PropertyFilterCriteria },
  TContext
> => {
  const mutationOptions = getFindGroupPropertiesSearch1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * This will return both owned Groups and Groups the user is a member of
 * @summary Return the groups list with specified user id
 */
export const findGroupsByUser1 = (
  params?: FindGroupsByUser1Params,
  signal?: AbortSignal,
) => {
  return customInstance<BaseFilterResult>({
    url: `/groups`,
    method: "GET",
    params,
    signal,
  });
};

export const getFindGroupsByUser1QueryKey = (
  params?: FindGroupsByUser1Params,
) => {
  return [`/groups`, ...(params ? [params] : [])] as const;
};

export const getFindGroupsByUser1QueryOptions = <
  TData = Awaited<ReturnType<typeof findGroupsByUser1>>,
  TError = void,
>(
  params?: FindGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindGroupsByUser1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findGroupsByUser1>>
  > = ({ signal }) => findGroupsByUser1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findGroupsByUser1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindGroupsByUser1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findGroupsByUser1>>
>;
export type FindGroupsByUser1QueryError = void;

export function useFindGroupsByUser1<
  TData = Awaited<ReturnType<typeof findGroupsByUser1>>,
  TError = void,
>(
  params: undefined | FindGroupsByUser1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findGroupsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findGroupsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findGroupsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindGroupsByUser1<
  TData = Awaited<ReturnType<typeof findGroupsByUser1>>,
  TError = void,
>(
  params?: FindGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findGroupsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findGroupsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findGroupsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindGroupsByUser1<
  TData = Awaited<ReturnType<typeof findGroupsByUser1>>,
  TError = void,
>(
  params?: FindGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the groups list with specified user id
 */

export function useFindGroupsByUser1<
  TData = Awaited<ReturnType<typeof findGroupsByUser1>>,
  TError = void,
>(
  params?: FindGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindGroupsByUser1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Consider that only user can saveNew its groups
 * @summary Create or update the group supplied
 */
export const saveGroup1 = (group: Group, signal?: AbortSignal) => {
  return customInstance<Group>({
    url: `/groups`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: group,
    signal,
  });
};

export const getSaveGroup1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveGroup1>>,
    TError,
    { data: Group },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveGroup1>>,
  TError,
  { data: Group },
  TContext
> => {
  const mutationKey = ["saveGroup1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveGroup1>>,
    { data: Group }
  > = (props) => {
    const { data } = props ?? {};

    return saveGroup1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveGroup1MutationResult = NonNullable<
  Awaited<ReturnType<typeof saveGroup1>>
>;
export type SaveGroup1MutationBody = Group;
export type SaveGroup1MutationError = void;

/**
 * @summary Create or update the group supplied
 */
export const useSaveGroup1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveGroup1>>,
      TError,
      { data: Group },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveGroup1>>,
  TError,
  { data: Group },
  TContext
> => {
  const mutationOptions = getSaveGroup1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Return the groups list with specified user id that are inactive
 */
export const findInactiveGroupsByUser1 = (
  params?: FindInactiveGroupsByUser1Params,
  signal?: AbortSignal,
) => {
  return customInstance<BaseFilterResult>({
    url: `/groups/inactive`,
    method: "GET",
    params,
    signal,
  });
};

export const getFindInactiveGroupsByUser1QueryKey = (
  params?: FindInactiveGroupsByUser1Params,
) => {
  return [`/groups/inactive`, ...(params ? [params] : [])] as const;
};

export const getFindInactiveGroupsByUser1QueryOptions = <
  TData = Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
  TError = void,
>(
  params?: FindInactiveGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindInactiveGroupsByUser1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findInactiveGroupsByUser1>>
  > = ({ signal }) => findInactiveGroupsByUser1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindInactiveGroupsByUser1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findInactiveGroupsByUser1>>
>;
export type FindInactiveGroupsByUser1QueryError = void;

export function useFindInactiveGroupsByUser1<
  TData = Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
  TError = void,
>(
  params: undefined | FindInactiveGroupsByUser1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findInactiveGroupsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindInactiveGroupsByUser1<
  TData = Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
  TError = void,
>(
  params?: FindInactiveGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findInactiveGroupsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindInactiveGroupsByUser1<
  TData = Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
  TError = void,
>(
  params?: FindInactiveGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the groups list with specified user id that are inactive
 */

export function useFindInactiveGroupsByUser1<
  TData = Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
  TError = void,
>(
  params?: FindInactiveGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findInactiveGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindInactiveGroupsByUser1QueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Return the groups list with specified user id that user has invitations of
 */
export const findInvitedGroupsByUser1 = (
  params?: FindInvitedGroupsByUser1Params,
  signal?: AbortSignal,
) => {
  return customInstance<BaseFilterResult>({
    url: `/groups/invited`,
    method: "GET",
    params,
    signal,
  });
};

export const getFindInvitedGroupsByUser1QueryKey = (
  params?: FindInvitedGroupsByUser1Params,
) => {
  return [`/groups/invited`, ...(params ? [params] : [])] as const;
};

export const getFindInvitedGroupsByUser1QueryOptions = <
  TData = Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
  TError = void,
>(
  params?: FindInvitedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindInvitedGroupsByUser1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findInvitedGroupsByUser1>>
  > = ({ signal }) => findInvitedGroupsByUser1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindInvitedGroupsByUser1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findInvitedGroupsByUser1>>
>;
export type FindInvitedGroupsByUser1QueryError = void;

export function useFindInvitedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
  TError = void,
>(
  params: undefined | FindInvitedGroupsByUser1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findInvitedGroupsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindInvitedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
  TError = void,
>(
  params?: FindInvitedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findInvitedGroupsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindInvitedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
  TError = void,
>(
  params?: FindInvitedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the groups list with specified user id that user has invitations of
 */

export function useFindInvitedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
  TError = void,
>(
  params?: FindInvitedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findInvitedGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindInvitedGroupsByUser1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Return the groups list with specified user id that user has requested
 */
export const findRequestedGroupsByUser1 = (
  params?: FindRequestedGroupsByUser1Params,
  signal?: AbortSignal,
) => {
  return customInstance<BaseFilterResult>({
    url: `/groups/requested`,
    method: "GET",
    params,
    signal,
  });
};

export const getFindRequestedGroupsByUser1QueryKey = (
  params?: FindRequestedGroupsByUser1Params,
) => {
  return [`/groups/requested`, ...(params ? [params] : [])] as const;
};

export const getFindRequestedGroupsByUser1QueryOptions = <
  TData = Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
  TError = void,
>(
  params?: FindRequestedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindRequestedGroupsByUser1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findRequestedGroupsByUser1>>
  > = ({ signal }) => findRequestedGroupsByUser1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindRequestedGroupsByUser1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findRequestedGroupsByUser1>>
>;
export type FindRequestedGroupsByUser1QueryError = void;

export function useFindRequestedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
  TError = void,
>(
  params: undefined | FindRequestedGroupsByUser1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findRequestedGroupsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindRequestedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
  TError = void,
>(
  params?: FindRequestedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findRequestedGroupsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindRequestedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
  TError = void,
>(
  params?: FindRequestedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the groups list with specified user id that user has requested
 */

export function useFindRequestedGroupsByUser1<
  TData = Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
  TError = void,
>(
  params?: FindRequestedGroupsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findRequestedGroupsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindRequestedGroupsByUser1QueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
 * @summary Retrieves property fields filtered by key
 */
export const getPropertyFilters2 = (
  propertyKey: PropertyKey,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/property-fields/filter-by-key`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: propertyKey,
    signal,
  });
};

export const getGetPropertyFilters2MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getPropertyFilters2>>,
    TError,
    { data: PropertyKey },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getPropertyFilters2>>,
  TError,
  { data: PropertyKey },
  TContext
> => {
  const mutationKey = ["getPropertyFilters2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getPropertyFilters2>>,
    { data: PropertyKey }
  > = (props) => {
    const { data } = props ?? {};

    return getPropertyFilters2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetPropertyFilters2MutationResult = NonNullable<
  Awaited<ReturnType<typeof getPropertyFilters2>>
>;
export type GetPropertyFilters2MutationBody = PropertyKey;
export type GetPropertyFilters2MutationError = void;

/**
 * @summary Retrieves property fields filtered by key
 */
export const useGetPropertyFilters2 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof getPropertyFilters2>>,
      TError,
      { data: PropertyKey },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof getPropertyFilters2>>,
  TError,
  { data: PropertyKey },
  TContext
> => {
  const mutationOptions = getGetPropertyFilters2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves options for a specific property filter based on submitted filters
 * @summary Get property field options
 */
export const getPropertyFieldOptions1 = (
  filterId: number,
  propertyFilterSubmission: PropertyFilterSubmission[],
  signal?: AbortSignal,
) => {
  return customInstance<GetPropertyFieldOptions1200>({
    url: `/property_filters/options/${filterId}`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: propertyFilterSubmission,
    signal,
  });
};

export const getGetPropertyFieldOptions1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getPropertyFieldOptions1>>,
    TError,
    { filterId: number; data: PropertyFilterSubmission[] },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getPropertyFieldOptions1>>,
  TError,
  { filterId: number; data: PropertyFilterSubmission[] },
  TContext
> => {
  const mutationKey = ["getPropertyFieldOptions1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getPropertyFieldOptions1>>,
    { filterId: number; data: PropertyFilterSubmission[] }
  > = (props) => {
    const { filterId, data } = props ?? {};

    return getPropertyFieldOptions1(filterId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetPropertyFieldOptions1MutationResult = NonNullable<
  Awaited<ReturnType<typeof getPropertyFieldOptions1>>
>;
export type GetPropertyFieldOptions1MutationBody = PropertyFilterSubmission[];
export type GetPropertyFieldOptions1MutationError = unknown;

/**
 * @summary Get property field options
 */
export const useGetPropertyFieldOptions1 = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof getPropertyFieldOptions1>>,
      TError,
      { filterId: number; data: PropertyFilterSubmission[] },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof getPropertyFieldOptions1>>,
  TError,
  { filterId: number; data: PropertyFilterSubmission[] },
  TContext
> => {
  const mutationOptions = getGetPropertyFieldOptions1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves a list of property filters, optionally filtered by filter nature IDs
 * @summary Get property filters
 */
export const getPropertyFilters = (
  params?: GetPropertyFiltersParams,
  signal?: AbortSignal,
) => {
  return customInstance<PropertyFilter[]>({
    url: `/property_filters`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetPropertyFiltersQueryKey = (
  params?: GetPropertyFiltersParams,
) => {
  return [`/property_filters`, ...(params ? [params] : [])] as const;
};

export const getGetPropertyFiltersQueryOptions = <
  TData = Awaited<ReturnType<typeof getPropertyFilters>>,
  TError = unknown,
>(
  params?: GetPropertyFiltersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertyFilters>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPropertyFiltersQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPropertyFilters>>
  > = ({ signal }) => getPropertyFilters(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPropertyFilters>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPropertyFiltersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPropertyFilters>>
>;
export type GetPropertyFiltersQueryError = unknown;

export function useGetPropertyFilters<
  TData = Awaited<ReturnType<typeof getPropertyFilters>>,
  TError = unknown,
>(
  params: undefined | GetPropertyFiltersParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertyFilters>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPropertyFilters>>,
          TError,
          Awaited<ReturnType<typeof getPropertyFilters>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPropertyFilters<
  TData = Awaited<ReturnType<typeof getPropertyFilters>>,
  TError = unknown,
>(
  params?: GetPropertyFiltersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertyFilters>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPropertyFilters>>,
          TError,
          Awaited<ReturnType<typeof getPropertyFilters>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPropertyFilters<
  TData = Awaited<ReturnType<typeof getPropertyFilters>>,
  TError = unknown,
>(
  params?: GetPropertyFiltersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertyFilters>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get property filters
 */

export function useGetPropertyFilters<
  TData = Awaited<ReturnType<typeof getPropertyFilters>>,
  TError = unknown,
>(
  params?: GetPropertyFiltersParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPropertyFilters>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPropertyFiltersQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves a list of all available property locations
 * @summary Method to find all the property locations
 */
export const getAllCountries = (signal?: AbortSignal) => {
  return customInstance<PropertyLocation[]>({
    url: `/property-locations`,
    method: "GET",
    signal,
  });
};

export const getGetAllCountriesQueryKey = () => {
  return [`/property-locations`] as const;
};

export const getGetAllCountriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllCountries>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllCountries>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllCountriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCountries>>> = ({
    signal,
  }) => getAllCountries(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllCountries>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllCountriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllCountries>>
>;
export type GetAllCountriesQueryError = void;

export function useGetAllCountries<
  TData = Awaited<ReturnType<typeof getAllCountries>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllCountries>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCountries>>,
          TError,
          Awaited<ReturnType<typeof getAllCountries>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllCountries<
  TData = Awaited<ReturnType<typeof getAllCountries>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllCountries>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllCountries>>,
          TError,
          Awaited<ReturnType<typeof getAllCountries>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllCountries<
  TData = Awaited<ReturnType<typeof getAllCountries>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllCountries>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Method to find all the property locations
 */

export function useGetAllCountries<
  TData = Awaited<ReturnType<typeof getAllCountries>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllCountries>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllCountriesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Method to find all the property proposals
 */
export const getAllPropertyProposals1 = (signal?: AbortSignal) => {
  return customInstance<PropertyProposal[]>({
    url: `/property-proposals`,
    method: "GET",
    signal,
  });
};

export const getGetAllPropertyProposals1QueryKey = () => {
  return [`/property-proposals`] as const;
};

export const getGetAllPropertyProposals1QueryOptions = <
  TData = Awaited<ReturnType<typeof getAllPropertyProposals1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllPropertyProposals1>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAllPropertyProposals1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllPropertyProposals1>>
  > = ({ signal }) => getAllPropertyProposals1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllPropertyProposals1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllPropertyProposals1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllPropertyProposals1>>
>;
export type GetAllPropertyProposals1QueryError = void;

export function useGetAllPropertyProposals1<
  TData = Awaited<ReturnType<typeof getAllPropertyProposals1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllPropertyProposals1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPropertyProposals1>>,
          TError,
          Awaited<ReturnType<typeof getAllPropertyProposals1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllPropertyProposals1<
  TData = Awaited<ReturnType<typeof getAllPropertyProposals1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllPropertyProposals1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPropertyProposals1>>,
          TError,
          Awaited<ReturnType<typeof getAllPropertyProposals1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllPropertyProposals1<
  TData = Awaited<ReturnType<typeof getAllPropertyProposals1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllPropertyProposals1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Method to find all the property proposals
 */

export function useGetAllPropertyProposals1<
  TData = Awaited<ReturnType<typeof getAllPropertyProposals1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllPropertyProposals1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllPropertyProposals1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Publication state update
 */
export const changePublicationStatus2 = (
  propertyId: string,
  changePublicationStatus2Body: ChangePublicationStatus2Body,
  signal?: AbortSignal,
) => {
  return customInstance<Property>({
    url: `/properties/${propertyId}/publication-state`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: changePublicationStatus2Body,
    signal,
  });
};

export const getChangePublicationStatus2MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof changePublicationStatus2>>,
    TError,
    { propertyId: string; data: ChangePublicationStatus2Body },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof changePublicationStatus2>>,
  TError,
  { propertyId: string; data: ChangePublicationStatus2Body },
  TContext
> => {
  const mutationKey = ["changePublicationStatus2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicationStatus2>>,
    { propertyId: string; data: ChangePublicationStatus2Body }
  > = (props) => {
    const { propertyId, data } = props ?? {};

    return changePublicationStatus2(propertyId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ChangePublicationStatus2MutationResult = NonNullable<
  Awaited<ReturnType<typeof changePublicationStatus2>>
>;
export type ChangePublicationStatus2MutationBody = ChangePublicationStatus2Body;
export type ChangePublicationStatus2MutationError = void;

/**
 * @summary Publication state update
 */
export const useChangePublicationStatus2 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof changePublicationStatus2>>,
      TError,
      { propertyId: string; data: ChangePublicationStatus2Body },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof changePublicationStatus2>>,
  TError,
  { propertyId: string; data: ChangePublicationStatus2Body },
  TContext
> => {
  const mutationOptions = getChangePublicationStatus2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * This process is not reversible
 * @summary Delete the property with id supplied
 */
export const deleteProperty1 = (id: string) => {
  return customInstance<string>({ url: `/properties/${id}`, method: "DELETE" });
};

export const getDeleteProperty1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProperty1>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProperty1>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteProperty1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProperty1>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteProperty1(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProperty1MutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProperty1>>
>;

export type DeleteProperty1MutationError = void;

/**
 * @summary Delete the property with id supplied
 */
export const useDeleteProperty1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProperty1>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProperty1>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteProperty1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns a randomized list of properties with the specified count limit
 * @summary Fetch random list of properties, with basic data
 */
export const fetchRandomProperties2 = (signal?: AbortSignal) => {
  return customInstance<Property[]>({
    url: `/properties/fetch-random`,
    method: "GET",
    signal,
  });
};

export const getFetchRandomProperties2QueryKey = () => {
  return [`/properties/fetch-random`] as const;
};

export const getFetchRandomProperties2QueryOptions = <
  TData = Awaited<ReturnType<typeof fetchRandomProperties2>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof fetchRandomProperties2>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFetchRandomProperties2QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchRandomProperties2>>
  > = ({ signal }) => fetchRandomProperties2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchRandomProperties2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FetchRandomProperties2QueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchRandomProperties2>>
>;
export type FetchRandomProperties2QueryError = void;

export function useFetchRandomProperties2<
  TData = Awaited<ReturnType<typeof fetchRandomProperties2>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchRandomProperties2>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchRandomProperties2>>,
          TError,
          Awaited<ReturnType<typeof fetchRandomProperties2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFetchRandomProperties2<
  TData = Awaited<ReturnType<typeof fetchRandomProperties2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchRandomProperties2>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchRandomProperties2>>,
          TError,
          Awaited<ReturnType<typeof fetchRandomProperties2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFetchRandomProperties2<
  TData = Awaited<ReturnType<typeof fetchRandomProperties2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchRandomProperties2>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Fetch random list of properties, with basic data
 */

export function useFetchRandomProperties2<
  TData = Awaited<ReturnType<typeof fetchRandomProperties2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchRandomProperties2>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFetchRandomProperties2QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Fetch random list of properties related to a given property
 */
export const fetchRandomProperties = (
  propertyId: string,
  signal?: AbortSignal,
) => {
  return customInstance<Property[]>({
    url: `/properties/${propertyId}/related-properties`,
    method: "GET",
    signal,
  });
};

export const getFetchRandomPropertiesQueryKey = (propertyId: string) => {
  return [`/properties/${propertyId}/related-properties`] as const;
};

export const getFetchRandomPropertiesQueryOptions = <
  TData = Awaited<ReturnType<typeof fetchRandomProperties>>,
  TError = void,
>(
  propertyId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchRandomProperties>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFetchRandomPropertiesQueryKey(propertyId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchRandomProperties>>
  > = ({ signal }) => fetchRandomProperties(propertyId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!propertyId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchRandomProperties>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FetchRandomPropertiesQueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchRandomProperties>>
>;
export type FetchRandomPropertiesQueryError = void;

export function useFetchRandomProperties<
  TData = Awaited<ReturnType<typeof fetchRandomProperties>>,
  TError = void,
>(
  propertyId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchRandomProperties>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchRandomProperties>>,
          TError,
          Awaited<ReturnType<typeof fetchRandomProperties>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFetchRandomProperties<
  TData = Awaited<ReturnType<typeof fetchRandomProperties>>,
  TError = void,
>(
  propertyId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchRandomProperties>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchRandomProperties>>,
          TError,
          Awaited<ReturnType<typeof fetchRandomProperties>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFetchRandomProperties<
  TData = Awaited<ReturnType<typeof fetchRandomProperties>>,
  TError = void,
>(
  propertyId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchRandomProperties>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Fetch random list of properties related to a given property
 */

export function useFetchRandomProperties<
  TData = Awaited<ReturnType<typeof fetchRandomProperties>>,
  TError = void,
>(
  propertyId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchRandomProperties>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFetchRandomPropertiesQueryOptions(
    propertyId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Search properties with specified filters
 */
export const findProperties1 = (
  propertyFilterCriteria: PropertyFilterCriteria,
  signal?: AbortSignal,
) => {
  return customInstance<Property[]>({
    url: `/properties/search`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: propertyFilterCriteria,
    signal,
  });
};

export const getFindProperties1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof findProperties1>>,
    TError,
    { data: PropertyFilterCriteria },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof findProperties1>>,
  TError,
  { data: PropertyFilterCriteria },
  TContext
> => {
  const mutationKey = ["findProperties1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof findProperties1>>,
    { data: PropertyFilterCriteria }
  > = (props) => {
    const { data } = props ?? {};

    return findProperties1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type FindProperties1MutationResult = NonNullable<
  Awaited<ReturnType<typeof findProperties1>>
>;
export type FindProperties1MutationBody = PropertyFilterCriteria;
export type FindProperties1MutationError = void;

/**
 * @summary Search properties with specified filters
 */
export const useFindProperties1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof findProperties1>>,
      TError,
      { data: PropertyFilterCriteria },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof findProperties1>>,
  TError,
  { data: PropertyFilterCriteria },
  TContext
> => {
  const mutationOptions = getFindProperties1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @deprecated
 * @summary Return the property list with specified user id
 */
export const findPropertiesByLocationRange1 = (
  range: string,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/properties/by_location_range/${range}`,
    method: "GET",
    signal,
  });
};

export const getFindPropertiesByLocationRange1QueryKey = (range: string) => {
  return [`/properties/by_location_range/${range}`] as const;
};

export const getFindPropertiesByLocationRange1QueryOptions = <
  TData = Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
  TError = void,
>(
  range: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindPropertiesByLocationRange1QueryKey(range);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findPropertiesByLocationRange1>>
  > = ({ signal }) => findPropertiesByLocationRange1(range, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!range,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindPropertiesByLocationRange1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findPropertiesByLocationRange1>>
>;
export type FindPropertiesByLocationRange1QueryError = void;

export function useFindPropertiesByLocationRange1<
  TData = Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
  TError = void,
>(
  range: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
          TError,
          Awaited<ReturnType<typeof findPropertiesByLocationRange1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindPropertiesByLocationRange1<
  TData = Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
  TError = void,
>(
  range: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
          TError,
          Awaited<ReturnType<typeof findPropertiesByLocationRange1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindPropertiesByLocationRange1<
  TData = Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
  TError = void,
>(
  range: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @deprecated
 * @summary Return the property list with specified user id
 */

export function useFindPropertiesByLocationRange1<
  TData = Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
  TError = void,
>(
  range: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertiesByLocationRange1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindPropertiesByLocationRange1QueryOptions(
    range,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Filter the properties existing in system with specified id. Returns empty if none property match the id
 * @summary Return the property with specified id
 */
export const findProperty1 = (
  propertyId: string,
  params?: FindProperty1Params,
  signal?: AbortSignal,
) => {
  return customInstance<Property>({
    url: `/properties/${propertyId}`,
    method: "GET",
    params,
    signal,
  });
};

export const getFindProperty1QueryKey = (
  propertyId: string,
  params?: FindProperty1Params,
) => {
  return [`/properties/${propertyId}`, ...(params ? [params] : [])] as const;
};

export const getFindProperty1QueryOptions = <
  TData = Awaited<ReturnType<typeof findProperty1>>,
  TError = void,
>(
  propertyId: string,
  params?: FindProperty1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findProperty1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindProperty1QueryKey(propertyId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findProperty1>>> = ({
    signal,
  }) => findProperty1(propertyId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!propertyId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findProperty1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindProperty1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findProperty1>>
>;
export type FindProperty1QueryError = void;

export function useFindProperty1<
  TData = Awaited<ReturnType<typeof findProperty1>>,
  TError = void,
>(
  propertyId: string,
  params: undefined | FindProperty1Params,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findProperty1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findProperty1>>,
          TError,
          Awaited<ReturnType<typeof findProperty1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindProperty1<
  TData = Awaited<ReturnType<typeof findProperty1>>,
  TError = void,
>(
  propertyId: string,
  params?: FindProperty1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findProperty1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findProperty1>>,
          TError,
          Awaited<ReturnType<typeof findProperty1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindProperty1<
  TData = Awaited<ReturnType<typeof findProperty1>>,
  TError = void,
>(
  propertyId: string,
  params?: FindProperty1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findProperty1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the property with specified id
 */

export function useFindProperty1<
  TData = Awaited<ReturnType<typeof findProperty1>>,
  TError = void,
>(
  propertyId: string,
  params?: FindProperty1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findProperty1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindProperty1QueryOptions(
    propertyId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Filter the properties existing in system with specified id. Returns empty if none property match the id
 * @summary Return the property with specified id
 */
export const findPropertyOldUrl1 = (id: string, signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `/properties/detail/${id}`,
    method: "GET",
    signal,
  });
};

export const getFindPropertyOldUrl1QueryKey = (id: string) => {
  return [`/properties/detail/${id}`] as const;
};

export const getFindPropertyOldUrl1QueryOptions = <
  TData = Awaited<ReturnType<typeof findPropertyOldUrl1>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertyOldUrl1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindPropertyOldUrl1QueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findPropertyOldUrl1>>
  > = ({ signal }) => findPropertyOldUrl1(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findPropertyOldUrl1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindPropertyOldUrl1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findPropertyOldUrl1>>
>;
export type FindPropertyOldUrl1QueryError = void;

export function useFindPropertyOldUrl1<
  TData = Awaited<ReturnType<typeof findPropertyOldUrl1>>,
  TError = void,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertyOldUrl1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPropertyOldUrl1>>,
          TError,
          Awaited<ReturnType<typeof findPropertyOldUrl1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindPropertyOldUrl1<
  TData = Awaited<ReturnType<typeof findPropertyOldUrl1>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertyOldUrl1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPropertyOldUrl1>>,
          TError,
          Awaited<ReturnType<typeof findPropertyOldUrl1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindPropertyOldUrl1<
  TData = Awaited<ReturnType<typeof findPropertyOldUrl1>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertyOldUrl1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the property with specified id
 */

export function useFindPropertyOldUrl1<
  TData = Awaited<ReturnType<typeof findPropertyOldUrl1>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertyOldUrl1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindPropertyOldUrl1QueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Password Protected Property for Signed in User
 */
export const getDraftsProperties1 = (signal?: AbortSignal) => {
  return customInstance<Property[]>({
    url: `/properties/drafts`,
    method: "GET",
    signal,
  });
};

export const getGetDraftsProperties1QueryKey = () => {
  return [`/properties/drafts`] as const;
};

export const getGetDraftsProperties1QueryOptions = <
  TData = Awaited<ReturnType<typeof getDraftsProperties1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDraftsProperties1>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDraftsProperties1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDraftsProperties1>>
  > = ({ signal }) => getDraftsProperties1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDraftsProperties1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDraftsProperties1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getDraftsProperties1>>
>;
export type GetDraftsProperties1QueryError = void;

export function useGetDraftsProperties1<
  TData = Awaited<ReturnType<typeof getDraftsProperties1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDraftsProperties1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftsProperties1>>,
          TError,
          Awaited<ReturnType<typeof getDraftsProperties1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDraftsProperties1<
  TData = Awaited<ReturnType<typeof getDraftsProperties1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDraftsProperties1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDraftsProperties1>>,
          TError,
          Awaited<ReturnType<typeof getDraftsProperties1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDraftsProperties1<
  TData = Awaited<ReturnType<typeof getDraftsProperties1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDraftsProperties1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Password Protected Property for Signed in User
 */

export function useGetDraftsProperties1<
  TData = Awaited<ReturnType<typeof getDraftsProperties1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDraftsProperties1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDraftsProperties1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get recently created properties within specified minutes (default 60)
 */
export const getRecentProperties1 = (
  params?: GetRecentProperties1Params,
  signal?: AbortSignal,
) => {
  return customInstance<Property[]>({
    url: `/properties/recent`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetRecentProperties1QueryKey = (
  params?: GetRecentProperties1Params,
) => {
  return [`/properties/recent`, ...(params ? [params] : [])] as const;
};

export const getGetRecentProperties1QueryOptions = <
  TData = Awaited<ReturnType<typeof getRecentProperties1>>,
  TError = void,
>(
  params?: GetRecentProperties1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentProperties1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecentProperties1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecentProperties1>>
  > = ({ signal }) => getRecentProperties1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentProperties1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecentProperties1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecentProperties1>>
>;
export type GetRecentProperties1QueryError = void;

export function useGetRecentProperties1<
  TData = Awaited<ReturnType<typeof getRecentProperties1>>,
  TError = void,
>(
  params: undefined | GetRecentProperties1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentProperties1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentProperties1>>,
          TError,
          Awaited<ReturnType<typeof getRecentProperties1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecentProperties1<
  TData = Awaited<ReturnType<typeof getRecentProperties1>>,
  TError = void,
>(
  params?: GetRecentProperties1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentProperties1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentProperties1>>,
          TError,
          Awaited<ReturnType<typeof getRecentProperties1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRecentProperties1<
  TData = Awaited<ReturnType<typeof getRecentProperties1>>,
  TError = void,
>(
  params?: GetRecentProperties1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentProperties1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get recently created properties within specified minutes (default 60)
 */

export function useGetRecentProperties1<
  TData = Awaited<ReturnType<typeof getRecentProperties1>>,
  TError = void,
>(
  params?: GetRecentProperties1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentProperties1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRecentProperties1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Password Protected Property for Signed in User
 */
export const getSecuredProperties1 = (signal?: AbortSignal) => {
  return customInstance<Property[]>({
    url: `/properties/password-protected`,
    method: "GET",
    signal,
  });
};

export const getGetSecuredProperties1QueryKey = () => {
  return [`/properties/password-protected`] as const;
};

export const getGetSecuredProperties1QueryOptions = <
  TData = Awaited<ReturnType<typeof getSecuredProperties1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getSecuredProperties1>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSecuredProperties1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSecuredProperties1>>
  > = ({ signal }) => getSecuredProperties1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSecuredProperties1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSecuredProperties1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getSecuredProperties1>>
>;
export type GetSecuredProperties1QueryError = void;

export function useGetSecuredProperties1<
  TData = Awaited<ReturnType<typeof getSecuredProperties1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSecuredProperties1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSecuredProperties1>>,
          TError,
          Awaited<ReturnType<typeof getSecuredProperties1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSecuredProperties1<
  TData = Awaited<ReturnType<typeof getSecuredProperties1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSecuredProperties1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSecuredProperties1>>,
          TError,
          Awaited<ReturnType<typeof getSecuredProperties1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSecuredProperties1<
  TData = Awaited<ReturnType<typeof getSecuredProperties1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSecuredProperties1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Password Protected Property for Signed in User
 */

export function useGetSecuredProperties1<
  TData = Awaited<ReturnType<typeof getSecuredProperties1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSecuredProperties1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSecuredProperties1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns HTML preview for sharing a property on social media or messaging apps
 * @summary Get HTML preview for a property
 */
export const previewProperty2 = (
  params: PreviewProperty2Params,
  signal?: AbortSignal,
) => {
  return customInstance<string>({
    url: `/properties/previews`,
    method: "GET",
    params,
    signal,
  });
};

export const getPreviewProperty2QueryKey = (params: PreviewProperty2Params) => {
  return [`/properties/previews`, ...(params ? [params] : [])] as const;
};

export const getPreviewProperty2QueryOptions = <
  TData = Awaited<ReturnType<typeof previewProperty2>>,
  TError = void,
>(
  params: PreviewProperty2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof previewProperty2>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPreviewProperty2QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof previewProperty2>>
  > = ({ signal }) => previewProperty2(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof previewProperty2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PreviewProperty2QueryResult = NonNullable<
  Awaited<ReturnType<typeof previewProperty2>>
>;
export type PreviewProperty2QueryError = void;

export function usePreviewProperty2<
  TData = Awaited<ReturnType<typeof previewProperty2>>,
  TError = void,
>(
  params: PreviewProperty2Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof previewProperty2>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof previewProperty2>>,
          TError,
          Awaited<ReturnType<typeof previewProperty2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePreviewProperty2<
  TData = Awaited<ReturnType<typeof previewProperty2>>,
  TError = void,
>(
  params: PreviewProperty2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof previewProperty2>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof previewProperty2>>,
          TError,
          Awaited<ReturnType<typeof previewProperty2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePreviewProperty2<
  TData = Awaited<ReturnType<typeof previewProperty2>>,
  TError = void,
>(
  params: PreviewProperty2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof previewProperty2>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get HTML preview for a property
 */

export function usePreviewProperty2<
  TData = Awaited<ReturnType<typeof previewProperty2>>,
  TError = void,
>(
  params: PreviewProperty2Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof previewProperty2>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPreviewProperty2QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Consider that only user can saveNew its properties
 * @summary Create or update the property supplied
 */
export const saveProperty1 = (property: Property, signal?: AbortSignal) => {
  return customInstance<Property>({
    url: `/properties`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: property,
    signal,
  });
};

export const getSaveProperty1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveProperty1>>,
    TError,
    { data: Property },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveProperty1>>,
  TError,
  { data: Property },
  TContext
> => {
  const mutationKey = ["saveProperty1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveProperty1>>,
    { data: Property }
  > = (props) => {
    const { data } = props ?? {};

    return saveProperty1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveProperty1MutationResult = NonNullable<
  Awaited<ReturnType<typeof saveProperty1>>
>;
export type SaveProperty1MutationBody = Property;
export type SaveProperty1MutationError = void;

/**
 * @summary Create or update the property supplied
 */
export const useSaveProperty1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveProperty1>>,
      TError,
      { data: Property },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveProperty1>>,
  TError,
  { data: Property },
  TContext
> => {
  const mutationOptions = getSaveProperty1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const sendAlert2 = (
  weeklyAlertRange: WeeklyAlertRange,
  signal?: AbortSignal,
) => {
  return customInstance<number>({
    url: `/properties/weekly-alert`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: weeklyAlertRange,
    signal,
  });
};

export const getSendAlert2MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendAlert2>>,
    TError,
    { data: WeeklyAlertRange },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendAlert2>>,
  TError,
  { data: WeeklyAlertRange },
  TContext
> => {
  const mutationKey = ["sendAlert2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendAlert2>>,
    { data: WeeklyAlertRange }
  > = (props) => {
    const { data } = props ?? {};

    return sendAlert2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendAlert2MutationResult = NonNullable<
  Awaited<ReturnType<typeof sendAlert2>>
>;
export type SendAlert2MutationBody = WeeklyAlertRange;
export type SendAlert2MutationError = void;

export const useSendAlert2 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendAlert2>>,
      TError,
      { data: WeeklyAlertRange },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sendAlert2>>,
  TError,
  { data: WeeklyAlertRange },
  TContext
> => {
  const mutationOptions = getSendAlert2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const sendGroupAlert1 = (signal?: AbortSignal) => {
  return customInstance<number>({
    url: `/properties/weekly-group-alert`,
    method: "POST",
    signal,
  });
};

export const getSendGroupAlert1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendGroupAlert1>>,
    TError,
    void,
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendGroupAlert1>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["sendGroupAlert1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendGroupAlert1>>,
    void
  > = () => {
    return sendGroupAlert1();
  };

  return { mutationFn, ...mutationOptions };
};

export type SendGroupAlert1MutationResult = NonNullable<
  Awaited<ReturnType<typeof sendGroupAlert1>>
>;

export type SendGroupAlert1MutationError = void;

export const useSendGroupAlert1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendGroupAlert1>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sendGroupAlert1>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getSendGroupAlert1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
 * @summary Get all property types
 */
export const getAllPropertyTypes1 = (signal?: AbortSignal) => {
  return customInstance<PropertyType[]>({
    url: `/property-types`,
    method: "GET",
    signal,
  });
};

export const getGetAllPropertyTypes1QueryKey = () => {
  return [`/property-types`] as const;
};

export const getGetAllPropertyTypes1QueryOptions = <
  TData = Awaited<ReturnType<typeof getAllPropertyTypes1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllPropertyTypes1>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllPropertyTypes1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllPropertyTypes1>>
  > = ({ signal }) => getAllPropertyTypes1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllPropertyTypes1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllPropertyTypes1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllPropertyTypes1>>
>;
export type GetAllPropertyTypes1QueryError = void;

export function useGetAllPropertyTypes1<
  TData = Awaited<ReturnType<typeof getAllPropertyTypes1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllPropertyTypes1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPropertyTypes1>>,
          TError,
          Awaited<ReturnType<typeof getAllPropertyTypes1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllPropertyTypes1<
  TData = Awaited<ReturnType<typeof getAllPropertyTypes1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllPropertyTypes1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllPropertyTypes1>>,
          TError,
          Awaited<ReturnType<typeof getAllPropertyTypes1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllPropertyTypes1<
  TData = Awaited<ReturnType<typeof getAllPropertyTypes1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllPropertyTypes1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all property types
 */

export function useGetAllPropertyTypes1<
  TData = Awaited<ReturnType<typeof getAllPropertyTypes1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllPropertyTypes1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAllPropertyTypes1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Publication state update
 */
export const changePublicationStatus = (
  testimonialId: string,
  publicationState: boolean,
  signal?: AbortSignal,
) => {
  return customInstance<Testimonial>({
    url: `/testimonial/${testimonialId}/publication-state/${publicationState}`,
    method: "POST",
    signal,
  });
};

export const getChangePublicationStatusMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof changePublicationStatus>>,
    TError,
    { testimonialId: string; publicationState: boolean },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof changePublicationStatus>>,
  TError,
  { testimonialId: string; publicationState: boolean },
  TContext
> => {
  const mutationKey = ["changePublicationStatus"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof changePublicationStatus>>,
    { testimonialId: string; publicationState: boolean }
  > = (props) => {
    const { testimonialId, publicationState } = props ?? {};

    return changePublicationStatus(testimonialId, publicationState);
  };

  return { mutationFn, ...mutationOptions };
};

export type ChangePublicationStatusMutationResult = NonNullable<
  Awaited<ReturnType<typeof changePublicationStatus>>
>;

export type ChangePublicationStatusMutationError = void;

/**
 * @summary Publication state update
 */
export const useChangePublicationStatus = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof changePublicationStatus>>,
      TError,
      { testimonialId: string; publicationState: boolean },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof changePublicationStatus>>,
  TError,
  { testimonialId: string; publicationState: boolean },
  TContext
> => {
  const mutationOptions = getChangePublicationStatusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Fetch User Posted list of testimonials
 */
export const fetchPublishedTestimonials1 = (
  params?: FetchPublishedTestimonials1Params,
  signal?: AbortSignal,
) => {
  return customInstance<TestimonialFilterResult>({
    url: `/testimonial/published`,
    method: "GET",
    params,
    signal,
  });
};

export const getFetchPublishedTestimonials1QueryKey = (
  params?: FetchPublishedTestimonials1Params,
) => {
  return [`/testimonial/published`, ...(params ? [params] : [])] as const;
};

export const getFetchPublishedTestimonials1QueryOptions = <
  TData = Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
  TError = void,
>(
  params?: FetchPublishedTestimonials1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFetchPublishedTestimonials1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchPublishedTestimonials1>>
  > = ({ signal }) => fetchPublishedTestimonials1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FetchPublishedTestimonials1QueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchPublishedTestimonials1>>
>;
export type FetchPublishedTestimonials1QueryError = void;

export function useFetchPublishedTestimonials1<
  TData = Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
  TError = void,
>(
  params: undefined | FetchPublishedTestimonials1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
          TError,
          Awaited<ReturnType<typeof fetchPublishedTestimonials1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFetchPublishedTestimonials1<
  TData = Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
  TError = void,
>(
  params?: FetchPublishedTestimonials1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
          TError,
          Awaited<ReturnType<typeof fetchPublishedTestimonials1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFetchPublishedTestimonials1<
  TData = Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
  TError = void,
>(
  params?: FetchPublishedTestimonials1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Fetch User Posted list of testimonials
 */

export function useFetchPublishedTestimonials1<
  TData = Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
  TError = void,
>(
  params?: FetchPublishedTestimonials1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchPublishedTestimonials1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFetchPublishedTestimonials1QueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Fetch User Received list of testimonials
 */
export const fetchReceivedTestimonials1 = (
  params?: FetchReceivedTestimonials1Params,
  signal?: AbortSignal,
) => {
  return customInstance<TestimonialFilterResult>({
    url: `/testimonial`,
    method: "GET",
    params,
    signal,
  });
};

export const getFetchReceivedTestimonials1QueryKey = (
  params?: FetchReceivedTestimonials1Params,
) => {
  return [`/testimonial`, ...(params ? [params] : [])] as const;
};

export const getFetchReceivedTestimonials1QueryOptions = <
  TData = Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
  TError = void,
>(
  params?: FetchReceivedTestimonials1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFetchReceivedTestimonials1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof fetchReceivedTestimonials1>>
  > = ({ signal }) => fetchReceivedTestimonials1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FetchReceivedTestimonials1QueryResult = NonNullable<
  Awaited<ReturnType<typeof fetchReceivedTestimonials1>>
>;
export type FetchReceivedTestimonials1QueryError = void;

export function useFetchReceivedTestimonials1<
  TData = Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
  TError = void,
>(
  params: undefined | FetchReceivedTestimonials1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
          TError,
          Awaited<ReturnType<typeof fetchReceivedTestimonials1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFetchReceivedTestimonials1<
  TData = Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
  TError = void,
>(
  params?: FetchReceivedTestimonials1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
          TError,
          Awaited<ReturnType<typeof fetchReceivedTestimonials1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFetchReceivedTestimonials1<
  TData = Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
  TError = void,
>(
  params?: FetchReceivedTestimonials1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Fetch User Received list of testimonials
 */

export function useFetchReceivedTestimonials1<
  TData = Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
  TError = void,
>(
  params?: FetchReceivedTestimonials1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof fetchReceivedTestimonials1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFetchReceivedTestimonials1QueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Consider that only user can save new testimonials
 * @summary Create or update the Testimonial supplied
 */
export const saveTestimonial1 = (
  testimonial: Testimonial,
  signal?: AbortSignal,
) => {
  return customInstance<Testimonial>({
    url: `/testimonial`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: testimonial,
    signal,
  });
};

export const getSaveTestimonial1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveTestimonial1>>,
    TError,
    { data: Testimonial },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveTestimonial1>>,
  TError,
  { data: Testimonial },
  TContext
> => {
  const mutationKey = ["saveTestimonial1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveTestimonial1>>,
    { data: Testimonial }
  > = (props) => {
    const { data } = props ?? {};

    return saveTestimonial1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveTestimonial1MutationResult = NonNullable<
  Awaited<ReturnType<typeof saveTestimonial1>>
>;
export type SaveTestimonial1MutationBody = Testimonial;
export type SaveTestimonial1MutationError = void;

/**
 * @summary Create or update the Testimonial supplied
 */
export const useSaveTestimonial1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveTestimonial1>>,
      TError,
      { data: Testimonial },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveTestimonial1>>,
  TError,
  { data: Testimonial },
  TContext
> => {
  const mutationOptions = getSaveTestimonial1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Return the testimonial with specified id, it needs to be published
 */
export const findTestimonial1 = (
  testimonialId: string,
  signal?: AbortSignal,
) => {
  return customInstance<Testimonial>({
    url: `/testimonial/${testimonialId}`,
    method: "GET",
    signal,
  });
};

export const getFindTestimonial1QueryKey = (testimonialId: string) => {
  return [`/testimonial/${testimonialId}`] as const;
};

export const getFindTestimonial1QueryOptions = <
  TData = Awaited<ReturnType<typeof findTestimonial1>>,
  TError = void,
>(
  testimonialId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonial1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindTestimonial1QueryKey(testimonialId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findTestimonial1>>
  > = ({ signal }) => findTestimonial1(testimonialId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!testimonialId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findTestimonial1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindTestimonial1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findTestimonial1>>
>;
export type FindTestimonial1QueryError = void;

export function useFindTestimonial1<
  TData = Awaited<ReturnType<typeof findTestimonial1>>,
  TError = void,
>(
  testimonialId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonial1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findTestimonial1>>,
          TError,
          Awaited<ReturnType<typeof findTestimonial1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindTestimonial1<
  TData = Awaited<ReturnType<typeof findTestimonial1>>,
  TError = void,
>(
  testimonialId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonial1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findTestimonial1>>,
          TError,
          Awaited<ReturnType<typeof findTestimonial1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindTestimonial1<
  TData = Awaited<ReturnType<typeof findTestimonial1>>,
  TError = void,
>(
  testimonialId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonial1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the testimonial with specified id, it needs to be published
 */

export function useFindTestimonial1<
  TData = Awaited<ReturnType<typeof findTestimonial1>>,
  TError = void,
>(
  testimonialId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonial1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindTestimonial1QueryOptions(testimonialId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Return the testimonial Requests a user Created
 */
export const findTestimonialRequests1 = (signal?: AbortSignal) => {
  return customInstance<Testimonial[]>({
    url: `/testimonial/requested`,
    method: "GET",
    signal,
  });
};

export const getFindTestimonialRequests1QueryKey = () => {
  return [`/testimonial/requested`] as const;
};

export const getFindTestimonialRequests1QueryOptions = <
  TData = Awaited<ReturnType<typeof findTestimonialRequests1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof findTestimonialRequests1>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindTestimonialRequests1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findTestimonialRequests1>>
  > = ({ signal }) => findTestimonialRequests1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findTestimonialRequests1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindTestimonialRequests1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findTestimonialRequests1>>
>;
export type FindTestimonialRequests1QueryError = void;

export function useFindTestimonialRequests1<
  TData = Awaited<ReturnType<typeof findTestimonialRequests1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialRequests1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findTestimonialRequests1>>,
          TError,
          Awaited<ReturnType<typeof findTestimonialRequests1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindTestimonialRequests1<
  TData = Awaited<ReturnType<typeof findTestimonialRequests1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialRequests1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findTestimonialRequests1>>,
          TError,
          Awaited<ReturnType<typeof findTestimonialRequests1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindTestimonialRequests1<
  TData = Awaited<ReturnType<typeof findTestimonialRequests1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialRequests1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the testimonial Requests a user Created
 */

export function useFindTestimonialRequests1<
  TData = Awaited<ReturnType<typeof findTestimonialRequests1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialRequests1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindTestimonialRequests1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Return the testimonial Requests a user Received
 */
export const findTestimonialRequestsReceived1 = (signal?: AbortSignal) => {
  return customInstance<Testimonial[]>({
    url: `/testimonial/request-received`,
    method: "GET",
    signal,
  });
};

export const getFindTestimonialRequestsReceived1QueryKey = () => {
  return [`/testimonial/request-received`] as const;
};

export const getFindTestimonialRequestsReceived1QueryOptions = <
  TData = Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindTestimonialRequestsReceived1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>
  > = ({ signal }) => findTestimonialRequestsReceived1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindTestimonialRequestsReceived1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>
>;
export type FindTestimonialRequestsReceived1QueryError = void;

export function useFindTestimonialRequestsReceived1<
  TData = Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
          TError,
          Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindTestimonialRequestsReceived1<
  TData = Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
          TError,
          Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindTestimonialRequestsReceived1<
  TData = Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the testimonial Requests a user Received
 */

export function useFindTestimonialRequestsReceived1<
  TData = Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialRequestsReceived1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindTestimonialRequestsReceived1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Return the property list with specified user id
 */
export const findPropertiesByUser1 = (
  id: string,
  params?: FindPropertiesByUser1Params,
  signal?: AbortSignal,
) => {
  return customInstance<PropertyFilterResult>({
    url: `/users/${id}/properties`,
    method: "GET",
    params,
    signal,
  });
};

export const getFindPropertiesByUser1QueryKey = (
  id: string,
  params?: FindPropertiesByUser1Params,
) => {
  return [`/users/${id}/properties`, ...(params ? [params] : [])] as const;
};

export const getFindPropertiesByUser1QueryOptions = <
  TData = Awaited<ReturnType<typeof findPropertiesByUser1>>,
  TError = void,
>(
  id: string,
  params?: FindPropertiesByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertiesByUser1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindPropertiesByUser1QueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findPropertiesByUser1>>
  > = ({ signal }) => findPropertiesByUser1(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findPropertiesByUser1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindPropertiesByUser1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findPropertiesByUser1>>
>;
export type FindPropertiesByUser1QueryError = void;

export function useFindPropertiesByUser1<
  TData = Awaited<ReturnType<typeof findPropertiesByUser1>>,
  TError = void,
>(
  id: string,
  params: undefined | FindPropertiesByUser1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertiesByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPropertiesByUser1>>,
          TError,
          Awaited<ReturnType<typeof findPropertiesByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindPropertiesByUser1<
  TData = Awaited<ReturnType<typeof findPropertiesByUser1>>,
  TError = void,
>(
  id: string,
  params?: FindPropertiesByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertiesByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPropertiesByUser1>>,
          TError,
          Awaited<ReturnType<typeof findPropertiesByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindPropertiesByUser1<
  TData = Awaited<ReturnType<typeof findPropertiesByUser1>>,
  TError = void,
>(
  id: string,
  params?: FindPropertiesByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertiesByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the property list with specified user id
 */

export function useFindPropertiesByUser1<
  TData = Awaited<ReturnType<typeof findPropertiesByUser1>>,
  TError = void,
>(
  id: string,
  params?: FindPropertiesByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findPropertiesByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindPropertiesByUser1QueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Return the testimonials list with specified user id
 */
export const findTestimonialsByUser1 = (
  id: string,
  params?: FindTestimonialsByUser1Params,
  signal?: AbortSignal,
) => {
  return customInstance<TestimonialFilterResult>({
    url: `/users/${id}/testimonials`,
    method: "GET",
    params,
    signal,
  });
};

export const getFindTestimonialsByUser1QueryKey = (
  id: string,
  params?: FindTestimonialsByUser1Params,
) => {
  return [`/users/${id}/testimonials`, ...(params ? [params] : [])] as const;
};

export const getFindTestimonialsByUser1QueryOptions = <
  TData = Awaited<ReturnType<typeof findTestimonialsByUser1>>,
  TError = void,
>(
  id: string,
  params?: FindTestimonialsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialsByUser1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindTestimonialsByUser1QueryKey(id, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findTestimonialsByUser1>>
  > = ({ signal }) => findTestimonialsByUser1(id, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findTestimonialsByUser1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindTestimonialsByUser1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findTestimonialsByUser1>>
>;
export type FindTestimonialsByUser1QueryError = void;

export function useFindTestimonialsByUser1<
  TData = Awaited<ReturnType<typeof findTestimonialsByUser1>>,
  TError = void,
>(
  id: string,
  params: undefined | FindTestimonialsByUser1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findTestimonialsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findTestimonialsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindTestimonialsByUser1<
  TData = Awaited<ReturnType<typeof findTestimonialsByUser1>>,
  TError = void,
>(
  id: string,
  params?: FindTestimonialsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findTestimonialsByUser1>>,
          TError,
          Awaited<ReturnType<typeof findTestimonialsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindTestimonialsByUser1<
  TData = Awaited<ReturnType<typeof findTestimonialsByUser1>>,
  TError = void,
>(
  id: string,
  params?: FindTestimonialsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the testimonials list with specified user id
 */

export function useFindTestimonialsByUser1<
  TData = Awaited<ReturnType<typeof findTestimonialsByUser1>>,
  TError = void,
>(
  id: string,
  params?: FindTestimonialsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findTestimonialsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindTestimonialsByUser1QueryOptions(
    id,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Request testimonial from specified user id
 */
export const requestTestimonialFromUser1 = (
  id: string,
  signal?: AbortSignal,
) => {
  return customInstance<TestimonialRequest>({
    url: `/users/${id}/request-testimonial`,
    method: "POST",
    signal,
  });
};

export const getRequestTestimonialFromUser1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestTestimonialFromUser1>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestTestimonialFromUser1>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["requestTestimonialFromUser1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestTestimonialFromUser1>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return requestTestimonialFromUser1(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type RequestTestimonialFromUser1MutationResult = NonNullable<
  Awaited<ReturnType<typeof requestTestimonialFromUser1>>
>;

export type RequestTestimonialFromUser1MutationError = void;

/**
 * @summary Request testimonial from specified user id
 */
export const useRequestTestimonialFromUser1 = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestTestimonialFromUser1>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof requestTestimonialFromUser1>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions =
    getRequestTestimonialFromUser1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const saveLog1 = (logEntry: LogEntry, signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `/log`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: logEntry,
    signal,
  });
};

export const getSaveLog1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveLog1>>,
    TError,
    { data: LogEntry },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveLog1>>,
  TError,
  { data: LogEntry },
  TContext
> => {
  const mutationKey = ["saveLog1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveLog1>>,
    { data: LogEntry }
  > = (props) => {
    const { data } = props ?? {};

    return saveLog1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveLog1MutationResult = NonNullable<
  Awaited<ReturnType<typeof saveLog1>>
>;
export type SaveLog1MutationBody = LogEntry;
export type SaveLog1MutationError = unknown;

export const useSaveLog1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveLog1>>,
      TError,
      { data: LogEntry },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveLog1>>,
  TError,
  { data: LogEntry },
  TContext
> => {
  const mutationOptions = getSaveLog1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * In this email it will be contained all process information to change password and recover access
 * @summary Send an email to user that has forgotted his/her password
 */
export const sendEmail1 = (signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `/password_recovery/send_email`,
    method: "GET",
    signal,
  });
};

export const getSendEmail1QueryKey = () => {
  return [`/password_recovery/send_email`] as const;
};

export const getSendEmail1QueryOptions = <
  TData = Awaited<ReturnType<typeof sendEmail1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof sendEmail1>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSendEmail1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof sendEmail1>>> = ({
    signal,
  }) => sendEmail1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof sendEmail1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SendEmail1QueryResult = NonNullable<
  Awaited<ReturnType<typeof sendEmail1>>
>;
export type SendEmail1QueryError = void;

export function useSendEmail1<
  TData = Awaited<ReturnType<typeof sendEmail1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sendEmail1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sendEmail1>>,
          TError,
          Awaited<ReturnType<typeof sendEmail1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSendEmail1<
  TData = Awaited<ReturnType<typeof sendEmail1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sendEmail1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sendEmail1>>,
          TError,
          Awaited<ReturnType<typeof sendEmail1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSendEmail1<
  TData = Awaited<ReturnType<typeof sendEmail1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sendEmail1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Send an email to user that has forgotted his/her password
 */

export function useSendEmail1<
  TData = Awaited<ReturnType<typeof sendEmail1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof sendEmail1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSendEmail1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update the password user, finishing the recovery password process
 */
export const updatePassword1 = (
  passwordRecoveryRequest: PasswordRecoveryRequest,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/password_recovery/update_password`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: passwordRecoveryRequest,
    signal,
  });
};

export const getUpdatePassword1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePassword1>>,
    TError,
    { data: PasswordRecoveryRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePassword1>>,
  TError,
  { data: PasswordRecoveryRequest },
  TContext
> => {
  const mutationKey = ["updatePassword1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePassword1>>,
    { data: PasswordRecoveryRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updatePassword1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePassword1MutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePassword1>>
>;
export type UpdatePassword1MutationBody = PasswordRecoveryRequest;
export type UpdatePassword1MutationError = void;

/**
 * @summary Update the password user, finishing the recovery password process
 */
export const useUpdatePassword1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePassword1>>,
      TError,
      { data: PasswordRecoveryRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updatePassword1>>,
  TError,
  { data: PasswordRecoveryRequest },
  TContext
> => {
  const mutationOptions = getUpdatePassword1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Validate that password recovery token supplied was valid and current
 */
export const validateToken1 = (signal?: AbortSignal) => {
  return customInstance<PasswordRecoveryRequest>({
    url: `/password_recovery/validate_token`,
    method: "GET",
    signal,
  });
};

export const getValidateToken1QueryKey = () => {
  return [`/password_recovery/validate_token`] as const;
};

export const getValidateToken1QueryOptions = <
  TData = Awaited<ReturnType<typeof validateToken1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof validateToken1>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getValidateToken1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof validateToken1>>> = ({
    signal,
  }) => validateToken1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof validateToken1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ValidateToken1QueryResult = NonNullable<
  Awaited<ReturnType<typeof validateToken1>>
>;
export type ValidateToken1QueryError = void;

export function useValidateToken1<
  TData = Awaited<ReturnType<typeof validateToken1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof validateToken1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateToken1>>,
          TError,
          Awaited<ReturnType<typeof validateToken1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useValidateToken1<
  TData = Awaited<ReturnType<typeof validateToken1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof validateToken1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateToken1>>,
          TError,
          Awaited<ReturnType<typeof validateToken1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useValidateToken1<
  TData = Awaited<ReturnType<typeof validateToken1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof validateToken1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Validate that password recovery token supplied was valid and current
 */

export function useValidateToken1<
  TData = Awaited<ReturnType<typeof validateToken1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof validateToken1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getValidateToken1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Generates an authorization code to be used with the token endpoint
 * @summary Authorize client application
 */
export const authorize1 = (signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `/security/auth`,
    method: "GET",
    signal,
  });
};

export const getAuthorize1QueryKey = () => {
  return [`/security/auth`] as const;
};

export const getAuthorize1QueryOptions = <
  TData = Awaited<ReturnType<typeof authorize1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof authorize1>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAuthorize1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof authorize1>>> = ({
    signal,
  }) => authorize1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authorize1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type Authorize1QueryResult = NonNullable<
  Awaited<ReturnType<typeof authorize1>>
>;
export type Authorize1QueryError = void;

export function useAuthorize1<
  TData = Awaited<ReturnType<typeof authorize1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authorize1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof authorize1>>,
          TError,
          Awaited<ReturnType<typeof authorize1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthorize1<
  TData = Awaited<ReturnType<typeof authorize1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authorize1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof authorize1>>,
          TError,
          Awaited<ReturnType<typeof authorize1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthorize1<
  TData = Awaited<ReturnType<typeof authorize1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authorize1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Authorize client application
 */

export function useAuthorize1<
  TData = Awaited<ReturnType<typeof authorize1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof authorize1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getAuthorize1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
 * @summary Exchange authorization code for access token
 */
export const requestToken1 = (
  requestToken1Body: RequestToken1Body,
  signal?: AbortSignal,
) => {
  const formUrlEncoded = new URLSearchParams();
  formUrlEncoded.append(`client-id`, requestToken1Body["client-id"]);
  formUrlEncoded.append(`code`, requestToken1Body.code);
  formUrlEncoded.append(`email`, requestToken1Body.email);
  formUrlEncoded.append(`password`, requestToken1Body.password);
  if (requestToken1Body.grant_type !== undefined) {
    formUrlEncoded.append(`grant_type`, requestToken1Body.grant_type);
  }
  if (requestToken1Body.client_secret !== undefined) {
    formUrlEncoded.append(`client_secret`, requestToken1Body.client_secret);
  }

  return customInstance<AuthInfoDto>({
    url: `/security/token`,
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    data: formUrlEncoded,
    signal,
  });
};

export const getRequestToken1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestToken1>>,
    TError,
    { data: RequestToken1Body },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestToken1>>,
  TError,
  { data: RequestToken1Body },
  TContext
> => {
  const mutationKey = ["requestToken1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestToken1>>,
    { data: RequestToken1Body }
  > = (props) => {
    const { data } = props ?? {};

    return requestToken1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RequestToken1MutationResult = NonNullable<
  Awaited<ReturnType<typeof requestToken1>>
>;
export type RequestToken1MutationBody = RequestToken1Body;
export type RequestToken1MutationError = void;

/**
 * @summary Exchange authorization code for access token
 */
export const useRequestToken1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestToken1>>,
      TError,
      { data: RequestToken1Body },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof requestToken1>>,
  TError,
  { data: RequestToken1Body },
  TContext
> => {
  const mutationOptions = getRequestToken1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create checkout-session
 */
export const createCheckoutSession2 = (
  checkoutSessionDto: CheckoutSessionDto,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/checkout-sessions`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: checkoutSessionDto,
    signal,
  });
};

export const getCreateCheckoutSession2MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCheckoutSession2>>,
    TError,
    { data: CheckoutSessionDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCheckoutSession2>>,
  TError,
  { data: CheckoutSessionDto },
  TContext
> => {
  const mutationKey = ["createCheckoutSession2"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCheckoutSession2>>,
    { data: CheckoutSessionDto }
  > = (props) => {
    const { data } = props ?? {};

    return createCheckoutSession2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateCheckoutSession2MutationResult = NonNullable<
  Awaited<ReturnType<typeof createCheckoutSession2>>
>;
export type CreateCheckoutSession2MutationBody = CheckoutSessionDto;
export type CreateCheckoutSession2MutationError = void;

/**
 * @summary Create checkout-session
 */
export const useCreateCheckoutSession2 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCheckoutSession2>>,
      TError,
      { data: CheckoutSessionDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createCheckoutSession2>>,
  TError,
  { data: CheckoutSessionDto },
  TContext
> => {
  const mutationOptions = getCreateCheckoutSession2MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Create checkout-session
 */
export const createCheckoutSession = (
  customerSessionDto: CustomerSessionDto,
  signal?: AbortSignal,
) => {
  return customInstance<void>({
    url: `/customer-sessions`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: customerSessionDto,
    signal,
  });
};

export const getCreateCheckoutSessionMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCheckoutSession>>,
    TError,
    { data: CustomerSessionDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCheckoutSession>>,
  TError,
  { data: CustomerSessionDto },
  TContext
> => {
  const mutationKey = ["createCheckoutSession"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCheckoutSession>>,
    { data: CustomerSessionDto }
  > = (props) => {
    const { data } = props ?? {};

    return createCheckoutSession(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateCheckoutSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCheckoutSession>>
>;
export type CreateCheckoutSessionMutationBody = CustomerSessionDto;
export type CreateCheckoutSessionMutationError = void;

/**
 * @summary Create checkout-session
 */
export const useCreateCheckoutSession = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCheckoutSession>>,
      TError,
      { data: CustomerSessionDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createCheckoutSession>>,
  TError,
  { data: CustomerSessionDto },
  TContext
> => {
  const mutationOptions = getCreateCheckoutSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Notify user subscription change
 */
export const postUserSubscriptionChange1 = (
  stripeEvent: StripeEvent,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/stripe-webhooks/user-subscription-update`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: stripeEvent,
    signal,
  });
};

export const getPostUserSubscriptionChange1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUserSubscriptionChange1>>,
    TError,
    { data: StripeEvent },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postUserSubscriptionChange1>>,
  TError,
  { data: StripeEvent },
  TContext
> => {
  const mutationKey = ["postUserSubscriptionChange1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUserSubscriptionChange1>>,
    { data: StripeEvent }
  > = (props) => {
    const { data } = props ?? {};

    return postUserSubscriptionChange1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUserSubscriptionChange1MutationResult = NonNullable<
  Awaited<ReturnType<typeof postUserSubscriptionChange1>>
>;
export type PostUserSubscriptionChange1MutationBody = StripeEvent;
export type PostUserSubscriptionChange1MutationError = void;

/**
 * @summary Notify user subscription change
 */
export const usePostUserSubscriptionChange1 = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postUserSubscriptionChange1>>,
      TError,
      { data: StripeEvent },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postUserSubscriptionChange1>>,
  TError,
  { data: StripeEvent },
  TContext
> => {
  const mutationOptions =
    getPostUserSubscriptionChange1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Return the active and available subscription plans
 */
export const getAll1 = (params?: GetAll1Params, signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `/subscription-plans`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetAll1QueryKey = (params?: GetAll1Params) => {
  return [`/subscription-plans`, ...(params ? [params] : [])] as const;
};

export const getGetAll1QueryOptions = <
  TData = Awaited<ReturnType<typeof getAll1>>,
  TError = void,
>(
  params?: GetAll1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAll1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAll1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll1>>> = ({
    signal,
  }) => getAll1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAll1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAll1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getAll1>>
>;
export type GetAll1QueryError = void;

export function useGetAll1<
  TData = Awaited<ReturnType<typeof getAll1>>,
  TError = void,
>(
  params: undefined | GetAll1Params,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAll1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAll1>>,
          TError,
          Awaited<ReturnType<typeof getAll1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAll1<
  TData = Awaited<ReturnType<typeof getAll1>>,
  TError = void,
>(
  params?: GetAll1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAll1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAll1>>,
          TError,
          Awaited<ReturnType<typeof getAll1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAll1<
  TData = Awaited<ReturnType<typeof getAll1>>,
  TError = void,
>(
  params?: GetAll1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAll1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return the active and available subscription plans
 */

export function useGetAll1<
  TData = Awaited<ReturnType<typeof getAll1>>,
  TError = void,
>(
  params?: GetAll1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAll1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAll1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const get = (userId: number, signal?: AbortSignal) => {
  return customInstance<UserSubscriptionDto>({
    url: `/users/${userId}/subscriptions`,
    method: "GET",
    signal,
  });
};

export const getGetQueryKey = (userId: number) => {
  return [`/users/${userId}/subscriptions`] as const;
};

export const getGetQueryOptions = <
  TData = Awaited<ReturnType<typeof get>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({
    signal,
  }) => get(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>;
export type GetQueryError = void;

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = void>(
  userId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof get>>,
          TError,
          Awaited<ReturnType<typeof get>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = void>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof get>>,
          TError,
          Awaited<ReturnType<typeof get>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = void>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = void>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetQueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getActiveFeatures1 = (userId: number, signal?: AbortSignal) => {
  return customInstance<SubscriptionPlanFeatureDto[]>({
    url: `/users/${userId}/subscriptions/active/features`,
    method: "GET",
    signal,
  });
};

export const getGetActiveFeatures1QueryKey = (userId: number) => {
  return [`/users/${userId}/subscriptions/active/features`] as const;
};

export const getGetActiveFeatures1QueryOptions = <
  TData = Awaited<ReturnType<typeof getActiveFeatures1>>,
  TError = SubscriptionPlanFeatureDto[],
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveFeatures1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetActiveFeatures1QueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getActiveFeatures1>>
  > = ({ signal }) => getActiveFeatures1(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getActiveFeatures1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActiveFeatures1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getActiveFeatures1>>
>;
export type GetActiveFeatures1QueryError = SubscriptionPlanFeatureDto[];

export function useGetActiveFeatures1<
  TData = Awaited<ReturnType<typeof getActiveFeatures1>>,
  TError = SubscriptionPlanFeatureDto[],
>(
  userId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveFeatures1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveFeatures1>>,
          TError,
          Awaited<ReturnType<typeof getActiveFeatures1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActiveFeatures1<
  TData = Awaited<ReturnType<typeof getActiveFeatures1>>,
  TError = SubscriptionPlanFeatureDto[],
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveFeatures1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActiveFeatures1>>,
          TError,
          Awaited<ReturnType<typeof getActiveFeatures1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActiveFeatures1<
  TData = Awaited<ReturnType<typeof getActiveFeatures1>>,
  TError = SubscriptionPlanFeatureDto[],
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveFeatures1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetActiveFeatures1<
  TData = Awaited<ReturnType<typeof getActiveFeatures1>>,
  TError = SubscriptionPlanFeatureDto[],
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActiveFeatures1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetActiveFeatures1QueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Deletes a specific alert owned by the user
 * @summary Delete an alert
 */
export const deleteAlert1 = (userId: number, alertId: number) => {
  return customInstance<string>({
    url: `/users/${userId}/alerts/${alertId}`,
    method: "DELETE",
  });
};

export const getDeleteAlert1MutationOptions = <
  TError = string,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAlert1>>,
    TError,
    { userId: number; alertId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAlert1>>,
  TError,
  { userId: number; alertId: number },
  TContext
> => {
  const mutationKey = ["deleteAlert1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAlert1>>,
    { userId: number; alertId: number }
  > = (props) => {
    const { userId, alertId } = props ?? {};

    return deleteAlert1(userId, alertId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAlert1MutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAlert1>>
>;

export type DeleteAlert1MutationError = string;

/**
 * @summary Delete an alert
 */
export const useDeleteAlert1 = <TError = string, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAlert1>>,
      TError,
      { userId: number; alertId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAlert1>>,
  TError,
  { userId: number; alertId: number },
  TContext
> => {
  const mutationOptions = getDeleteAlert1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves the results for a specific alert
 * @summary Get alert results
 */
export const getAlertResult1 = (
  userId: number,
  alertId: number,
  signal?: AbortSignal,
) => {
  return customInstance<GetAlertResult1200>({
    url: `/users/${userId}/alerts/${alertId}/result`,
    method: "GET",
    signal,
  });
};

export const getGetAlertResult1QueryKey = (userId: number, alertId: number) => {
  return [`/users/${userId}/alerts/${alertId}/result`] as const;
};

export const getGetAlertResult1QueryOptions = <
  TData = Awaited<ReturnType<typeof getAlertResult1>>,
  TError = string,
>(
  userId: number,
  alertId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlertResult1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAlertResult1QueryKey(userId, alertId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlertResult1>>> = ({
    signal,
  }) => getAlertResult1(userId, alertId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(userId && alertId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAlertResult1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAlertResult1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertResult1>>
>;
export type GetAlertResult1QueryError = string;

export function useGetAlertResult1<
  TData = Awaited<ReturnType<typeof getAlertResult1>>,
  TError = string,
>(
  userId: number,
  alertId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlertResult1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAlertResult1>>,
          TError,
          Awaited<ReturnType<typeof getAlertResult1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAlertResult1<
  TData = Awaited<ReturnType<typeof getAlertResult1>>,
  TError = string,
>(
  userId: number,
  alertId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlertResult1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAlertResult1>>,
          TError,
          Awaited<ReturnType<typeof getAlertResult1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAlertResult1<
  TData = Awaited<ReturnType<typeof getAlertResult1>>,
  TError = string,
>(
  userId: number,
  alertId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlertResult1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get alert results
 */

export function useGetAlertResult1<
  TData = Awaited<ReturnType<typeof getAlertResult1>>,
  TError = string,
>(
  userId: number,
  alertId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlertResult1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAlertResult1QueryOptions(userId, alertId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns all alerts associated with the specified user ID
 * @summary Get all alerts for a user
 */
export const getByUser2 = (userId: number, signal?: AbortSignal) => {
  return customInstance<Alert[]>({
    url: `/users/${userId}/alerts`,
    method: "GET",
    signal,
  });
};

export const getGetByUser2QueryKey = (userId: number) => {
  return [`/users/${userId}/alerts`] as const;
};

export const getGetByUser2QueryOptions = <
  TData = Awaited<ReturnType<typeof getByUser2>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByUser2>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetByUser2QueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getByUser2>>> = ({
    signal,
  }) => getByUser2(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getByUser2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetByUser2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getByUser2>>
>;
export type GetByUser2QueryError = string;

export function useGetByUser2<
  TData = Awaited<ReturnType<typeof getByUser2>>,
  TError = string,
>(
  userId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByUser2>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getByUser2>>,
          TError,
          Awaited<ReturnType<typeof getByUser2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetByUser2<
  TData = Awaited<ReturnType<typeof getByUser2>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByUser2>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getByUser2>>,
          TError,
          Awaited<ReturnType<typeof getByUser2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetByUser2<
  TData = Awaited<ReturnType<typeof getByUser2>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByUser2>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all alerts for a user
 */

export function useGetByUser2<
  TData = Awaited<ReturnType<typeof getByUser2>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByUser2>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByUser2QueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates a new alert for the specified user
 * @summary Create a new alert
 */
export const saveAlert1 = (
  userId: number,
  alert: Alert,
  signal?: AbortSignal,
) => {
  return customInstance<Alert>({
    url: `/users/${userId}/alerts`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: alert,
    signal,
  });
};

export const getSaveAlert1MutationOptions = <
  TError = string,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveAlert1>>,
    TError,
    { userId: number; data: Alert },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveAlert1>>,
  TError,
  { userId: number; data: Alert },
  TContext
> => {
  const mutationKey = ["saveAlert1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveAlert1>>,
    { userId: number; data: Alert }
  > = (props) => {
    const { userId, data } = props ?? {};

    return saveAlert1(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveAlert1MutationResult = NonNullable<
  Awaited<ReturnType<typeof saveAlert1>>
>;
export type SaveAlert1MutationBody = Alert;
export type SaveAlert1MutationError = string;

/**
 * @summary Create a new alert
 */
export const useSaveAlert1 = <TError = string, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveAlert1>>,
      TError,
      { userId: number; data: Alert },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof saveAlert1>>,
  TError,
  { userId: number; data: Alert },
  TContext
> => {
  const mutationOptions = getSaveAlert1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves all newsletters that the specified user has subscribed to
 * @summary Get newsletters subscribed to
 */
export const newsletterAlerts1 = (userId: number, signal?: AbortSignal) => {
  return customInstance<NewsletterSubscriberDto[]>({
    url: `/users/${userId}/alerts/newsletter-alerts`,
    method: "GET",
    signal,
  });
};

export const getNewsletterAlerts1QueryKey = (userId: number) => {
  return [`/users/${userId}/alerts/newsletter-alerts`] as const;
};

export const getNewsletterAlerts1QueryOptions = <
  TData = Awaited<ReturnType<typeof newsletterAlerts1>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof newsletterAlerts1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getNewsletterAlerts1QueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof newsletterAlerts1>>
  > = ({ signal }) => newsletterAlerts1(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof newsletterAlerts1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type NewsletterAlerts1QueryResult = NonNullable<
  Awaited<ReturnType<typeof newsletterAlerts1>>
>;
export type NewsletterAlerts1QueryError = string;

export function useNewsletterAlerts1<
  TData = Awaited<ReturnType<typeof newsletterAlerts1>>,
  TError = string,
>(
  userId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof newsletterAlerts1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof newsletterAlerts1>>,
          TError,
          Awaited<ReturnType<typeof newsletterAlerts1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNewsletterAlerts1<
  TData = Awaited<ReturnType<typeof newsletterAlerts1>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof newsletterAlerts1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof newsletterAlerts1>>,
          TError,
          Awaited<ReturnType<typeof newsletterAlerts1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNewsletterAlerts1<
  TData = Awaited<ReturnType<typeof newsletterAlerts1>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof newsletterAlerts1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get newsletters subscribed to
 */

export function useNewsletterAlerts1<
  TData = Awaited<ReturnType<typeof newsletterAlerts1>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof newsletterAlerts1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getNewsletterAlerts1QueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves all subscribers to newsletters owned by the specified user
 * @summary Get newsletter subscribers
 */
export const newsletterSubscribers1 = (
  userId: number,
  signal?: AbortSignal,
) => {
  return customInstance<NewsletterSubscriberDto[]>({
    url: `/users/${userId}/alerts/newsletter-subscribers`,
    method: "GET",
    signal,
  });
};

export const getNewsletterSubscribers1QueryKey = (userId: number) => {
  return [`/users/${userId}/alerts/newsletter-subscribers`] as const;
};

export const getNewsletterSubscribers1QueryOptions = <
  TData = Awaited<ReturnType<typeof newsletterSubscribers1>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof newsletterSubscribers1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getNewsletterSubscribers1QueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof newsletterSubscribers1>>
  > = ({ signal }) => newsletterSubscribers1(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof newsletterSubscribers1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type NewsletterSubscribers1QueryResult = NonNullable<
  Awaited<ReturnType<typeof newsletterSubscribers1>>
>;
export type NewsletterSubscribers1QueryError = string;

export function useNewsletterSubscribers1<
  TData = Awaited<ReturnType<typeof newsletterSubscribers1>>,
  TError = string,
>(
  userId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof newsletterSubscribers1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof newsletterSubscribers1>>,
          TError,
          Awaited<ReturnType<typeof newsletterSubscribers1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNewsletterSubscribers1<
  TData = Awaited<ReturnType<typeof newsletterSubscribers1>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof newsletterSubscribers1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof newsletterSubscribers1>>,
          TError,
          Awaited<ReturnType<typeof newsletterSubscribers1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useNewsletterSubscribers1<
  TData = Awaited<ReturnType<typeof newsletterSubscribers1>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof newsletterSubscribers1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get newsletter subscribers
 */

export function useNewsletterSubscribers1<
  TData = Awaited<ReturnType<typeof newsletterSubscribers1>>,
  TError = string,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof newsletterSubscribers1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getNewsletterSubscribers1QueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Triggers the sending of customized property alerts to users
 * @summary Send customized property alerts
 */
export const sendAlert = (userId: number, signal?: AbortSignal) => {
  return customInstance<string>({
    url: `/users/${userId}/alerts/send-alert`,
    method: "POST",
    signal,
  });
};

export const getSendAlertMutationOptions = <
  TError = string,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendAlert>>,
    TError,
    { userId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendAlert>>,
  TError,
  { userId: number },
  TContext
> => {
  const mutationKey = ["sendAlert"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendAlert>>,
    { userId: number }
  > = (props) => {
    const { userId } = props ?? {};

    return sendAlert(userId);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendAlertMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendAlert>>
>;

export type SendAlertMutationError = string;

/**
 * @summary Send customized property alerts
 */
export const useSendAlert = <TError = string, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendAlert>>,
      TError,
      { userId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sendAlert>>,
  TError,
  { userId: number },
  TContext
> => {
  const mutationOptions = getSendAlertMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns a list of all available brokerages in the system
 * @summary Retrieve all brokerages
 */
export const retrieve1 = (signal?: AbortSignal) => {
  return customInstance<Brokerage[]>({
    url: `/brokerages`,
    method: "GET",
    signal,
  });
};

export const getRetrieve1QueryKey = () => {
  return [`/brokerages`] as const;
};

export const getRetrieve1QueryOptions = <
  TData = Awaited<ReturnType<typeof retrieve1>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof retrieve1>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetrieve1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieve1>>> = ({
    signal,
  }) => retrieve1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof retrieve1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type Retrieve1QueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieve1>>
>;
export type Retrieve1QueryError = unknown;

export function useRetrieve1<
  TData = Awaited<ReturnType<typeof retrieve1>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof retrieve1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieve1>>,
          TError,
          Awaited<ReturnType<typeof retrieve1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieve1<
  TData = Awaited<ReturnType<typeof retrieve1>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof retrieve1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieve1>>,
          TError,
          Awaited<ReturnType<typeof retrieve1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieve1<
  TData = Awaited<ReturnType<typeof retrieve1>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof retrieve1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve all brokerages
 */

export function useRetrieve1<
  TData = Awaited<ReturnType<typeof retrieve1>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof retrieve1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRetrieve1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Gets all endorsements for a specified user. Can be filtered by endorser ID.
 * @summary Retrieve endorsements for a user
 */
export const retrieveEndorsementsByUser1 = (
  userId: number,
  params?: RetrieveEndorsementsByUser1Params,
  signal?: AbortSignal,
) => {
  return customInstance<SkillEndorsement[]>({
    url: `/users/${userId}/endorsements`,
    method: "GET",
    params,
    signal,
  });
};

export const getRetrieveEndorsementsByUser1QueryKey = (
  userId: number,
  params?: RetrieveEndorsementsByUser1Params,
) => {
  return [
    `/users/${userId}/endorsements`,
    ...(params ? [params] : []),
  ] as const;
};

export const getRetrieveEndorsementsByUser1QueryOptions = <
  TData = Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
  TError = void,
>(
  userId: number,
  params?: RetrieveEndorsementsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRetrieveEndorsementsByUser1QueryKey(userId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>
  > = ({ signal }) => retrieveEndorsementsByUser1(userId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RetrieveEndorsementsByUser1QueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>
>;
export type RetrieveEndorsementsByUser1QueryError = void;

export function useRetrieveEndorsementsByUser1<
  TData = Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
  TError = void,
>(
  userId: number,
  params: undefined | RetrieveEndorsementsByUser1Params,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
          TError,
          Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveEndorsementsByUser1<
  TData = Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
  TError = void,
>(
  userId: number,
  params?: RetrieveEndorsementsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
          TError,
          Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveEndorsementsByUser1<
  TData = Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
  TError = void,
>(
  userId: number,
  params?: RetrieveEndorsementsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve endorsements for a user
 */

export function useRetrieveEndorsementsByUser1<
  TData = Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
  TError = void,
>(
  userId: number,
  params?: RetrieveEndorsementsByUser1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveEndorsementsByUser1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRetrieveEndorsementsByUser1QueryOptions(
    userId,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves all favorites for a specific user
 * @summary Get user favorites
 */
export const getByUser = (
  userId: number,
  params?: GetByUserParams,
  signal?: AbortSignal,
) => {
  return customInstance<Favorite[]>({
    url: `/users/${userId}/favorites`,
    method: "GET",
    params,
    signal,
  });
};

export const getGetByUserQueryKey = (
  userId: number,
  params?: GetByUserParams,
) => {
  return [`/users/${userId}/favorites`, ...(params ? [params] : [])] as const;
};

export const getGetByUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getByUser>>,
  TError = void,
>(
  userId: number,
  params?: GetByUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByUser>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetByUserQueryKey(userId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getByUser>>> = ({
    signal,
  }) => getByUser(userId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getByUser>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetByUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getByUser>>
>;
export type GetByUserQueryError = void;

export function useGetByUser<
  TData = Awaited<ReturnType<typeof getByUser>>,
  TError = void,
>(
  userId: number,
  params: undefined | GetByUserParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getByUser>>,
          TError,
          Awaited<ReturnType<typeof getByUser>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetByUser<
  TData = Awaited<ReturnType<typeof getByUser>>,
  TError = void,
>(
  userId: number,
  params?: GetByUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getByUser>>,
          TError,
          Awaited<ReturnType<typeof getByUser>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetByUser<
  TData = Awaited<ReturnType<typeof getByUser>>,
  TError = void,
>(
  userId: number,
  params?: GetByUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByUser>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user favorites
 */

export function useGetByUser<
  TData = Awaited<ReturnType<typeof getByUser>>,
  TError = void,
>(
  userId: number,
  params?: GetByUserParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByUser>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByUserQueryOptions(userId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Adds a new favorite item for a specific user
 * @summary Add a favorite
 */
export const postUserFavorite1 = (
  userId: number,
  favorite: Favorite,
  signal?: AbortSignal,
) => {
  return customInstance<Favorite>({
    url: `/users/${userId}/favorites`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: favorite,
    signal,
  });
};

export const getPostUserFavorite1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUserFavorite1>>,
    TError,
    { userId: number; data: Favorite },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postUserFavorite1>>,
  TError,
  { userId: number; data: Favorite },
  TContext
> => {
  const mutationKey = ["postUserFavorite1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUserFavorite1>>,
    { userId: number; data: Favorite }
  > = (props) => {
    const { userId, data } = props ?? {};

    return postUserFavorite1(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUserFavorite1MutationResult = NonNullable<
  Awaited<ReturnType<typeof postUserFavorite1>>
>;
export type PostUserFavorite1MutationBody = Favorite;
export type PostUserFavorite1MutationError = void;

/**
 * @summary Add a favorite
 */
export const usePostUserFavorite1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postUserFavorite1>>,
      TError,
      { userId: number; data: Favorite },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postUserFavorite1>>,
  TError,
  { userId: number; data: Favorite },
  TContext
> => {
  const mutationOptions = getPostUserFavorite1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Removes a specific favorite from a user's favorites list
 * @summary Remove a favorite
 */
export const removeUserFavorite1 = (userId: number, favoriteId: number) => {
  return customInstance<unknown>({
    url: `/users/${userId}/favorites/${favoriteId}`,
    method: "DELETE",
  });
};

export const getRemoveUserFavorite1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeUserFavorite1>>,
    TError,
    { userId: number; favoriteId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeUserFavorite1>>,
  TError,
  { userId: number; favoriteId: number },
  TContext
> => {
  const mutationKey = ["removeUserFavorite1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeUserFavorite1>>,
    { userId: number; favoriteId: number }
  > = (props) => {
    const { userId, favoriteId } = props ?? {};

    return removeUserFavorite1(userId, favoriteId);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveUserFavorite1MutationResult = NonNullable<
  Awaited<ReturnType<typeof removeUserFavorite1>>
>;

export type RemoveUserFavorite1MutationError = void;

/**
 * @summary Remove a favorite
 */
export const useRemoveUserFavorite1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeUserFavorite1>>,
      TError,
      { userId: number; favoriteId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeUserFavorite1>>,
  TError,
  { userId: number; favoriteId: number },
  TContext
> => {
  const mutationOptions = getRemoveUserFavorite1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Searches for users within a specific group matching the specified filter criteria
 * @summary Search users within a specified group
 */
export const searchGroupUsers1 = (
  groupId: string,
  userFilterRequest: UserFilterRequest,
  signal?: AbortSignal,
) => {
  return customInstance<UserFilterResult>({
    url: `/groups/${groupId}/users/search`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userFilterRequest,
    signal,
  });
};

export const getSearchGroupUsers1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchGroupUsers1>>,
    TError,
    { groupId: string; data: UserFilterRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchGroupUsers1>>,
  TError,
  { groupId: string; data: UserFilterRequest },
  TContext
> => {
  const mutationKey = ["searchGroupUsers1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchGroupUsers1>>,
    { groupId: string; data: UserFilterRequest }
  > = (props) => {
    const { groupId, data } = props ?? {};

    return searchGroupUsers1(groupId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SearchGroupUsers1MutationResult = NonNullable<
  Awaited<ReturnType<typeof searchGroupUsers1>>
>;
export type SearchGroupUsers1MutationBody = UserFilterRequest;
export type SearchGroupUsers1MutationError = void;

/**
 * @summary Search users within a specified group
 */
export const useSearchGroupUsers1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof searchGroupUsers1>>,
      TError,
      { groupId: string; data: UserFilterRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof searchGroupUsers1>>,
  TError,
  { groupId: string; data: UserFilterRequest },
  TContext
> => {
  const mutationOptions = getSearchGroupUsers1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns a list of all available user skills in the system
 * @summary Retrieve all user skills
 */
export const retrieveUserSkills2 = (signal?: AbortSignal) => {
  return customInstance<Skill[]>({ url: `/skills`, method: "GET", signal });
};

export const getRetrieveUserSkills2QueryKey = () => {
  return [`/skills`] as const;
};

export const getRetrieveUserSkills2QueryOptions = <
  TData = Awaited<ReturnType<typeof retrieveUserSkills2>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof retrieveUserSkills2>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetrieveUserSkills2QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof retrieveUserSkills2>>
  > = ({ signal }) => retrieveUserSkills2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof retrieveUserSkills2>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RetrieveUserSkills2QueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveUserSkills2>>
>;
export type RetrieveUserSkills2QueryError = void;

export function useRetrieveUserSkills2<
  TData = Awaited<ReturnType<typeof retrieveUserSkills2>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserSkills2>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveUserSkills2>>,
          TError,
          Awaited<ReturnType<typeof retrieveUserSkills2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveUserSkills2<
  TData = Awaited<ReturnType<typeof retrieveUserSkills2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserSkills2>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveUserSkills2>>,
          TError,
          Awaited<ReturnType<typeof retrieveUserSkills2>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveUserSkills2<
  TData = Awaited<ReturnType<typeof retrieveUserSkills2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserSkills2>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve all user skills
 */

export function useRetrieveUserSkills2<
  TData = Awaited<ReturnType<typeof retrieveUserSkills2>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserSkills2>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRetrieveUserSkills2QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns all available user types in the system
 * @summary Get user types
 */
export const getUserTypes1 = (signal?: AbortSignal) => {
  return customInstance<UserType[]>({
    url: `/user-types`,
    method: "GET",
    signal,
  });
};

export const getGetUserTypes1QueryKey = () => {
  return [`/user-types`] as const;
};

export const getGetUserTypes1QueryOptions = <
  TData = Awaited<ReturnType<typeof getUserTypes1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUserTypes1>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserTypes1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserTypes1>>> = ({
    signal,
  }) => getUserTypes1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserTypes1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserTypes1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserTypes1>>
>;
export type GetUserTypes1QueryError = void;

export function useGetUserTypes1<
  TData = Awaited<ReturnType<typeof getUserTypes1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserTypes1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTypes1>>,
          TError,
          Awaited<ReturnType<typeof getUserTypes1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserTypes1<
  TData = Awaited<ReturnType<typeof getUserTypes1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserTypes1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserTypes1>>,
          TError,
          Awaited<ReturnType<typeof getUserTypes1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserTypes1<
  TData = Awaited<ReturnType<typeof getUserTypes1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserTypes1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user types
 */

export function useGetUserTypes1<
  TData = Awaited<ReturnType<typeof getUserTypes1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserTypes1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserTypes1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Activates a user account using the activation key sent to their email
 * @summary Activate the account of specified user
 */
export const activateUser1 = (signal?: AbortSignal) => {
  return customInstance<string>({
    url: `/users/activate-user`,
    method: "GET",
    signal,
  });
};

export const getActivateUser1QueryKey = () => {
  return [`/users/activate-user`] as const;
};

export const getActivateUser1QueryOptions = <
  TData = Awaited<ReturnType<typeof activateUser1>>,
  TError = void,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof activateUser1>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getActivateUser1QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof activateUser1>>> = ({
    signal,
  }) => activateUser1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof activateUser1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ActivateUser1QueryResult = NonNullable<
  Awaited<ReturnType<typeof activateUser1>>
>;
export type ActivateUser1QueryError = void;

export function useActivateUser1<
  TData = Awaited<ReturnType<typeof activateUser1>>,
  TError = void,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof activateUser1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof activateUser1>>,
          TError,
          Awaited<ReturnType<typeof activateUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useActivateUser1<
  TData = Awaited<ReturnType<typeof activateUser1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof activateUser1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof activateUser1>>,
          TError,
          Awaited<ReturnType<typeof activateUser1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useActivateUser1<
  TData = Awaited<ReturnType<typeof activateUser1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof activateUser1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Activate the account of specified user
 */

export function useActivateUser1<
  TData = Awaited<ReturnType<typeof activateUser1>>,
  TError = void,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof activateUser1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getActivateUser1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Verifies the code that was sent to the user's phone
 * @summary Verify the phone code sent to user
 */
export const checkPhoneVerificationCodeCommand1 = (
  userId: number,
  phoneCodeCheckResource: PhoneCodeCheckResource,
  signal?: AbortSignal,
) => {
  return customInstance<PhoneCodeCheckResource>({
    url: `/users/${userId}/phone-code-check`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: phoneCodeCheckResource,
    signal,
  });
};

export const getCheckPhoneVerificationCodeCommand1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof checkPhoneVerificationCodeCommand1>>,
    TError,
    { userId: number; data: PhoneCodeCheckResource },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof checkPhoneVerificationCodeCommand1>>,
  TError,
  { userId: number; data: PhoneCodeCheckResource },
  TContext
> => {
  const mutationKey = ["checkPhoneVerificationCodeCommand1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof checkPhoneVerificationCodeCommand1>>,
    { userId: number; data: PhoneCodeCheckResource }
  > = (props) => {
    const { userId, data } = props ?? {};

    return checkPhoneVerificationCodeCommand1(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CheckPhoneVerificationCodeCommand1MutationResult = NonNullable<
  Awaited<ReturnType<typeof checkPhoneVerificationCodeCommand1>>
>;
export type CheckPhoneVerificationCodeCommand1MutationBody =
  PhoneCodeCheckResource;
export type CheckPhoneVerificationCodeCommand1MutationError = void;

/**
 * @summary Verify the phone code sent to user
 */
export const useCheckPhoneVerificationCodeCommand1 = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof checkPhoneVerificationCodeCommand1>>,
      TError,
      { userId: number; data: PhoneCodeCheckResource },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof checkPhoneVerificationCodeCommand1>>,
  TError,
  { userId: number; data: PhoneCodeCheckResource },
  TContext
> => {
  const mutationOptions =
    getCheckPhoneVerificationCodeCommand1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieves a random selection of users based on specified criteria
 * @summary Fetch random list of users, with basic data
 */
export const fetchRandomUsers1 = (
  userListRequest: UserListRequest,
  signal?: AbortSignal,
) => {
  return customInstance<SkilledUser[]>({
    url: `/users/fetch-random`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userListRequest,
    signal,
  });
};

export const getFetchRandomUsers1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fetchRandomUsers1>>,
    TError,
    { data: UserListRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof fetchRandomUsers1>>,
  TError,
  { data: UserListRequest },
  TContext
> => {
  const mutationKey = ["fetchRandomUsers1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof fetchRandomUsers1>>,
    { data: UserListRequest }
  > = (props) => {
    const { data } = props ?? {};

    return fetchRandomUsers1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type FetchRandomUsers1MutationResult = NonNullable<
  Awaited<ReturnType<typeof fetchRandomUsers1>>
>;
export type FetchRandomUsers1MutationBody = UserListRequest;
export type FetchRandomUsers1MutationError = void;

/**
 * @summary Fetch random list of users, with basic data
 */
export const useFetchRandomUsers1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof fetchRandomUsers1>>,
      TError,
      { data: UserListRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof fetchRandomUsers1>>,
  TError,
  { data: UserListRequest },
  TContext
> => {
  const mutationOptions = getFetchRandomUsers1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Gets detailed user information by user ID
 * @summary Fetch user detail according to its id
 */
export const find = (userId: number, signal?: AbortSignal) => {
  return customInstance<SkilledUser>({
    url: `/users/${userId}`,
    method: "GET",
    signal,
  });
};

export const getFindQueryKey = (userId: number) => {
  return [`/users/${userId}`] as const;
};

export const getFindQueryOptions = <
  TData = Awaited<ReturnType<typeof find>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof find>>> = ({
    signal,
  }) => find(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof find>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type FindQueryResult = NonNullable<Awaited<ReturnType<typeof find>>>;
export type FindQueryError = void;

export function useFind<
  TData = Awaited<ReturnType<typeof find>>,
  TError = void,
>(
  userId: number,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof find>>,
          TError,
          Awaited<ReturnType<typeof find>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFind<
  TData = Awaited<ReturnType<typeof find>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof find>>,
          TError,
          Awaited<ReturnType<typeof find>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFind<
  TData = Awaited<ReturnType<typeof find>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Fetch user detail according to its id
 */

export function useFind<
  TData = Awaited<ReturnType<typeof find>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindQueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Gets user information by their unique profile name
 * @summary Fetch user detail according to its profile name
 */
export const find1 = (params?: Find1Params, signal?: AbortSignal) => {
  return customInstance<SkilledUser[]>({
    url: `/users`,
    method: "GET",
    params,
    signal,
  });
};

export const getFind1QueryKey = (params?: Find1Params) => {
  return [`/users`, ...(params ? [params] : [])] as const;
};

export const getFind1QueryOptions = <
  TData = Awaited<ReturnType<typeof find1>>,
  TError = void,
>(
  params?: Find1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFind1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof find1>>> = ({
    signal,
  }) => find1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof find1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type Find1QueryResult = NonNullable<Awaited<ReturnType<typeof find1>>>;
export type Find1QueryError = void;

export function useFind1<
  TData = Awaited<ReturnType<typeof find1>>,
  TError = void,
>(
  params: undefined | Find1Params,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof find1>>,
          TError,
          Awaited<ReturnType<typeof find1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFind1<
  TData = Awaited<ReturnType<typeof find1>>,
  TError = void,
>(
  params?: Find1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof find1>>,
          TError,
          Awaited<ReturnType<typeof find1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFind1<
  TData = Awaited<ReturnType<typeof find1>>,
  TError = void,
>(
  params?: Find1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Fetch user detail according to its profile name
 */

export function useFind1<
  TData = Awaited<ReturnType<typeof find1>>,
  TError = void,
>(
  params?: Find1Params,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof find1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFind1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates user profile information in the system
 * @summary Save the data of user in the system
 */
export const save = (skilledUser: SkilledUser, signal?: AbortSignal) => {
  return customInstance<string>({
    url: `/users`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: skilledUser,
    signal,
  });
};

export const getSaveMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof save>>,
    TError,
    { data: SkilledUser },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof save>>,
  TError,
  { data: SkilledUser },
  TContext
> => {
  const mutationKey = ["save"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof save>>,
    { data: SkilledUser }
  > = (props) => {
    const { data } = props ?? {};

    return save(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveMutationResult = NonNullable<Awaited<ReturnType<typeof save>>>;
export type SaveMutationBody = SkilledUser;
export type SaveMutationError = void;

/**
 * @summary Save the data of user in the system
 */
export const useSave = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof save>>,
      TError,
      { data: SkilledUser },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof save>>,
  TError,
  { data: SkilledUser },
  TContext
> => {
  const mutationOptions = getSaveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Gets detailed information for multiple users by their IDs
 * @summary Fetch multiple user detail according to its ids
 */
export const findList1 = (userIds: string, signal?: AbortSignal) => {
  return customInstance<SkilledUser[]>({
    url: `/users/list/${userIds}`,
    method: "GET",
    signal,
  });
};

export const getFindList1QueryKey = (userIds: string) => {
  return [`/users/list/${userIds}`] as const;
};

export const getFindList1QueryOptions = <
  TData = Awaited<ReturnType<typeof findList1>>,
  TError = void,
>(
  userIds: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findList1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindList1QueryKey(userIds);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findList1>>> = ({
    signal,
  }) => findList1(userIds, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userIds,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof findList1>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type FindList1QueryResult = NonNullable<
  Awaited<ReturnType<typeof findList1>>
>;
export type FindList1QueryError = void;

export function useFindList1<
  TData = Awaited<ReturnType<typeof findList1>>,
  TError = void,
>(
  userIds: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findList1>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findList1>>,
          TError,
          Awaited<ReturnType<typeof findList1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindList1<
  TData = Awaited<ReturnType<typeof findList1>>,
  TError = void,
>(
  userIds: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findList1>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findList1>>,
          TError,
          Awaited<ReturnType<typeof findList1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindList1<
  TData = Awaited<ReturnType<typeof findList1>>,
  TError = void,
>(
  userIds: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findList1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Fetch multiple user detail according to its ids
 */

export function useFindList1<
  TData = Awaited<ReturnType<typeof findList1>>,
  TError = void,
>(
  userIds: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findList1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindList1QueryOptions(userIds, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves the list of connections for a specific user
 * @summary Get a user connections
 */
export const findUserConnections = (userId: number, signal?: AbortSignal) => {
  return customInstance<SkilledUser[]>({
    url: `/users/${userId}/connections`,
    method: "GET",
    signal,
  });
};

export const getFindUserConnectionsQueryKey = (userId: number) => {
  return [`/users/${userId}/connections`] as const;
};

export const getFindUserConnectionsQueryOptions = <
  TData = Awaited<ReturnType<typeof findUserConnections>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserConnections>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getFindUserConnectionsQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof findUserConnections>>
  > = ({ signal }) => findUserConnections(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof findUserConnections>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindUserConnectionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof findUserConnections>>
>;
export type FindUserConnectionsQueryError = void;

export function useFindUserConnections<
  TData = Awaited<ReturnType<typeof findUserConnections>>,
  TError = void,
>(
  userId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findUserConnections>>,
          TError,
          Awaited<ReturnType<typeof findUserConnections>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindUserConnections<
  TData = Awaited<ReturnType<typeof findUserConnections>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserConnections>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findUserConnections>>,
          TError,
          Awaited<ReturnType<typeof findUserConnections>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useFindUserConnections<
  TData = Awaited<ReturnType<typeof findUserConnections>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserConnections>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a user connections
 */

export function useFindUserConnections<
  TData = Awaited<ReturnType<typeof findUserConnections>>,
  TError = void,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof findUserConnections>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getFindUserConnectionsQueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieves all users who have subscribed to the specified subscription plan
 * @summary Gets the users subscribed to a subscription plan name like Professional
 */
export const getSubscribedUsers1 = (
  subscriptionPlanName: string,
  signal?: AbortSignal,
) => {
  return customInstance<SubscribedUser[]>({
    url: `/users/subscribed-users/${subscriptionPlanName}`,
    method: "GET",
    signal,
  });
};

export const getGetSubscribedUsers1QueryKey = (
  subscriptionPlanName: string,
) => {
  return [`/users/subscribed-users/${subscriptionPlanName}`] as const;
};

export const getGetSubscribedUsers1QueryOptions = <
  TData = Awaited<ReturnType<typeof getSubscribedUsers1>>,
  TError = void,
>(
  subscriptionPlanName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubscribedUsers1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetSubscribedUsers1QueryKey(subscriptionPlanName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSubscribedUsers1>>
  > = ({ signal }) => getSubscribedUsers1(subscriptionPlanName, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!subscriptionPlanName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSubscribedUsers1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSubscribedUsers1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubscribedUsers1>>
>;
export type GetSubscribedUsers1QueryError = void;

export function useGetSubscribedUsers1<
  TData = Awaited<ReturnType<typeof getSubscribedUsers1>>,
  TError = void,
>(
  subscriptionPlanName: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubscribedUsers1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubscribedUsers1>>,
          TError,
          Awaited<ReturnType<typeof getSubscribedUsers1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubscribedUsers1<
  TData = Awaited<ReturnType<typeof getSubscribedUsers1>>,
  TError = void,
>(
  subscriptionPlanName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubscribedUsers1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubscribedUsers1>>,
          TError,
          Awaited<ReturnType<typeof getSubscribedUsers1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubscribedUsers1<
  TData = Awaited<ReturnType<typeof getSubscribedUsers1>>,
  TError = void,
>(
  subscriptionPlanName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubscribedUsers1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets the users subscribed to a subscription plan name like Professional
 */

export function useGetSubscribedUsers1<
  TData = Awaited<ReturnType<typeof getSubscribedUsers1>>,
  TError = void,
>(
  subscriptionPlanName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubscribedUsers1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSubscribedUsers1QueryOptions(
    subscriptionPlanName,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Generates an HTML preview of a user profile for sharing purposes
 * @summary Get HTML preview of a user profile
 */
export const previewProperty = (
  params?: PreviewPropertyParams,
  signal?: AbortSignal,
) => {
  return customInstance<string>({
    url: `/users/previews`,
    method: "GET",
    params,
    signal,
  });
};

export const getPreviewPropertyQueryKey = (params?: PreviewPropertyParams) => {
  return [`/users/previews`, ...(params ? [params] : [])] as const;
};

export const getPreviewPropertyQueryOptions = <
  TData = Awaited<ReturnType<typeof previewProperty>>,
  TError = void,
>(
  params?: PreviewPropertyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof previewProperty>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getPreviewPropertyQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof previewProperty>>> = ({
    signal,
  }) => previewProperty(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof previewProperty>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PreviewPropertyQueryResult = NonNullable<
  Awaited<ReturnType<typeof previewProperty>>
>;
export type PreviewPropertyQueryError = void;

export function usePreviewProperty<
  TData = Awaited<ReturnType<typeof previewProperty>>,
  TError = void,
>(
  params: undefined | PreviewPropertyParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof previewProperty>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof previewProperty>>,
          TError,
          Awaited<ReturnType<typeof previewProperty>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePreviewProperty<
  TData = Awaited<ReturnType<typeof previewProperty>>,
  TError = void,
>(
  params?: PreviewPropertyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof previewProperty>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof previewProperty>>,
          TError,
          Awaited<ReturnType<typeof previewProperty>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePreviewProperty<
  TData = Awaited<ReturnType<typeof previewProperty>>,
  TError = void,
>(
  params?: PreviewPropertyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof previewProperty>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get HTML preview of a user profile
 */

export function usePreviewProperty<
  TData = Awaited<ReturnType<typeof previewProperty>>,
  TError = void,
>(
  params?: PreviewPropertyParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof previewProperty>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getPreviewPropertyQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Creates a new user account in the system
 * @summary Register new user in the system
 */
export const register1 = (
  skilledUser: SkilledUser,
  params?: Register1Params,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/users/register`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: skilledUser,
    params,
    signal,
  });
};

export const getRegister1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof register1>>,
    TError,
    { data: SkilledUser; params?: Register1Params },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof register1>>,
  TError,
  { data: SkilledUser; params?: Register1Params },
  TContext
> => {
  const mutationKey = ["register1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof register1>>,
    { data: SkilledUser; params?: Register1Params }
  > = (props) => {
    const { data, params } = props ?? {};

    return register1(data, params);
  };

  return { mutationFn, ...mutationOptions };
};

export type Register1MutationResult = NonNullable<
  Awaited<ReturnType<typeof register1>>
>;
export type Register1MutationBody = SkilledUser;
export type Register1MutationError = void;

/**
 * @summary Register new user in the system
 */
export const useRegister1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof register1>>,
      TError,
      { data: SkilledUser; params?: Register1Params },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof register1>>,
  TError,
  { data: SkilledUser; params?: Register1Params },
  TContext
> => {
  const mutationOptions = getRegister1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Sends an activation link to the user's email for account verification
 * @summary Request activation link
 */
export const requestActivationLink1 = (
  requestActivationLink1Body: RequestActivationLink1Body,
  signal?: AbortSignal,
) => {
  const formUrlEncoded = new URLSearchParams();
  if (requestActivationLink1Body.email !== undefined) {
    formUrlEncoded.append(`email`, requestActivationLink1Body.email);
  }
  if (requestActivationLink1Body.password !== undefined) {
    formUrlEncoded.append(`password`, requestActivationLink1Body.password);
  }

  return customInstance<void>({
    url: `/users/activation_link_request`,
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    data: formUrlEncoded,
    signal,
  });
};

export const getRequestActivationLink1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestActivationLink1>>,
    TError,
    { data: RequestActivationLink1Body },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestActivationLink1>>,
  TError,
  { data: RequestActivationLink1Body },
  TContext
> => {
  const mutationKey = ["requestActivationLink1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestActivationLink1>>,
    { data: RequestActivationLink1Body }
  > = (props) => {
    const { data } = props ?? {};

    return requestActivationLink1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RequestActivationLink1MutationResult = NonNullable<
  Awaited<ReturnType<typeof requestActivationLink1>>
>;
export type RequestActivationLink1MutationBody = RequestActivationLink1Body;
export type RequestActivationLink1MutationError = void;

/**
 * @summary Request activation link
 */
export const useRequestActivationLink1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestActivationLink1>>,
      TError,
      { data: RequestActivationLink1Body },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof requestActivationLink1>>,
  TError,
  { data: RequestActivationLink1Body },
  TContext
> => {
  const mutationOptions = getRequestActivationLink1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Searches for users matching the specified filter criteria
 * @summary Search users with specified filters
 */
export const searchUsers1 = (
  userFilterRequest: UserFilterRequest,
  signal?: AbortSignal,
) => {
  return customInstance<UserFilterResult>({
    url: `/users/search`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userFilterRequest,
    signal,
  });
};

export const getSearchUsers1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof searchUsers1>>,
    TError,
    { data: UserFilterRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof searchUsers1>>,
  TError,
  { data: UserFilterRequest },
  TContext
> => {
  const mutationKey = ["searchUsers1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof searchUsers1>>,
    { data: UserFilterRequest }
  > = (props) => {
    const { data } = props ?? {};

    return searchUsers1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SearchUsers1MutationResult = NonNullable<
  Awaited<ReturnType<typeof searchUsers1>>
>;
export type SearchUsers1MutationBody = UserFilterRequest;
export type SearchUsers1MutationError = void;

/**
 * @summary Search users with specified filters
 */
export const useSearchUsers1 = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof searchUsers1>>,
      TError,
      { data: UserFilterRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof searchUsers1>>,
  TError,
  { data: UserFilterRequest },
  TContext
> => {
  const mutationOptions = getSearchUsers1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const sendPayedSusbscribersAlert1 = (signal?: AbortSignal) => {
  return customInstance<unknown>({
    url: `/users/weekly-payed-subscribers-alert`,
    method: "GET",
    signal,
  });
};

export const getSendPayedSusbscribersAlert1QueryKey = () => {
  return [`/users/weekly-payed-subscribers-alert`] as const;
};

export const getSendPayedSusbscribersAlert1QueryOptions = <
  TData = Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSendPayedSusbscribersAlert1QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>
  > = ({ signal }) => sendPayedSusbscribersAlert1(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SendPayedSusbscribersAlert1QueryResult = NonNullable<
  Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>
>;
export type SendPayedSusbscribersAlert1QueryError = unknown;

export function useSendPayedSusbscribersAlert1<
  TData = Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
          TError,
          Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSendPayedSusbscribersAlert1<
  TData = Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
          TError,
          Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSendPayedSusbscribersAlert1<
  TData = Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useSendPayedSusbscribersAlert1<
  TData = Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof sendPayedSusbscribersAlert1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSendPayedSusbscribersAlert1QueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Sends a verification code to the user's phone number for verification purposes
 * @summary Send a code to the previously saved phone number of the user
 */
export const sendPhoneVerificationCodeCommand1 = (
  userId: number,
  phoneCodeRequestResource: PhoneCodeRequestResource,
  signal?: AbortSignal,
) => {
  return customInstance<PhoneCodeRequestResource>({
    url: `/users/${userId}/phone-code-request`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: phoneCodeRequestResource,
    signal,
  });
};

export const getSendPhoneVerificationCodeCommand1MutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendPhoneVerificationCodeCommand1>>,
    TError,
    { userId: number; data: PhoneCodeRequestResource },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendPhoneVerificationCodeCommand1>>,
  TError,
  { userId: number; data: PhoneCodeRequestResource },
  TContext
> => {
  const mutationKey = ["sendPhoneVerificationCodeCommand1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendPhoneVerificationCodeCommand1>>,
    { userId: number; data: PhoneCodeRequestResource }
  > = (props) => {
    const { userId, data } = props ?? {};

    return sendPhoneVerificationCodeCommand1(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendPhoneVerificationCodeCommand1MutationResult = NonNullable<
  Awaited<ReturnType<typeof sendPhoneVerificationCodeCommand1>>
>;
export type SendPhoneVerificationCodeCommand1MutationBody =
  PhoneCodeRequestResource;
export type SendPhoneVerificationCodeCommand1MutationError = void;

/**
 * @summary Send a code to the previously saved phone number of the user
 */
export const useSendPhoneVerificationCodeCommand1 = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendPhoneVerificationCodeCommand1>>,
      TError,
      { userId: number; data: PhoneCodeRequestResource },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sendPhoneVerificationCodeCommand1>>,
  TError,
  { userId: number; data: PhoneCodeRequestResource },
  TContext
> => {
  const mutationOptions =
    getSendPhoneVerificationCodeCommand1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns all skills associated with a user
 * @summary Retrieve user skills
 */
export const retrieveUserSkills = (userId: number, signal?: AbortSignal) => {
  return customInstance<UserSkill[]>({
    url: `/users/${userId}/skills`,
    method: "GET",
    signal,
  });
};

export const getRetrieveUserSkillsQueryKey = (userId: number) => {
  return [`/users/${userId}/skills`] as const;
};

export const getRetrieveUserSkillsQueryOptions = <
  TData = Awaited<ReturnType<typeof retrieveUserSkills>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserSkills>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRetrieveUserSkillsQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof retrieveUserSkills>>
  > = ({ signal }) => retrieveUserSkills(userId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof retrieveUserSkills>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RetrieveUserSkillsQueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveUserSkills>>
>;
export type RetrieveUserSkillsQueryError = unknown;

export function useRetrieveUserSkills<
  TData = Awaited<ReturnType<typeof retrieveUserSkills>>,
  TError = unknown,
>(
  userId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserSkills>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveUserSkills>>,
          TError,
          Awaited<ReturnType<typeof retrieveUserSkills>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveUserSkills<
  TData = Awaited<ReturnType<typeof retrieveUserSkills>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserSkills>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveUserSkills>>,
          TError,
          Awaited<ReturnType<typeof retrieveUserSkills>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveUserSkills<
  TData = Awaited<ReturnType<typeof retrieveUserSkills>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserSkills>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve user skills
 */

export function useRetrieveUserSkills<
  TData = Awaited<ReturnType<typeof retrieveUserSkills>>,
  TError = unknown,
>(
  userId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveUserSkills>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRetrieveUserSkillsQueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * This endpoint is not supported. Use save user profile to update skills instead.
 * @summary Add user skills
 */
export const addUserSkills1 = (
  userId: number,
  userSkill: UserSkill[],
  signal?: AbortSignal,
) => {
  return customInstance<unknown>({
    url: `/users/${userId}/skills`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userSkill,
    signal,
  });
};

export const getAddUserSkills1MutationOptions = <
  TError = string,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addUserSkills1>>,
    TError,
    { userId: number; data: UserSkill[] },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addUserSkills1>>,
  TError,
  { userId: number; data: UserSkill[] },
  TContext
> => {
  const mutationKey = ["addUserSkills1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addUserSkills1>>,
    { userId: number; data: UserSkill[] }
  > = (props) => {
    const { userId, data } = props ?? {};

    return addUserSkills1(userId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddUserSkills1MutationResult = NonNullable<
  Awaited<ReturnType<typeof addUserSkills1>>
>;
export type AddUserSkills1MutationBody = UserSkill[];
export type AddUserSkills1MutationError = string;

/**
 * @summary Add user skills
 */
export const useAddUserSkills1 = <TError = string, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addUserSkills1>>,
      TError,
      { userId: number; data: UserSkill[] },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof addUserSkills1>>,
  TError,
  { userId: number; data: UserSkill[] },
  TContext
> => {
  const mutationOptions = getAddUserSkills1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Returns all endorsements for a specific user skill
 * @summary Retrieve skill endorsements
 */
export const retrieveSkillEndorsements1 = (
  userId: number,
  skillId: number,
  signal?: AbortSignal,
) => {
  return customInstance<SkillEndorsement[]>({
    url: `/users/${userId}/skills/${skillId}/endorsements`,
    method: "GET",
    signal,
  });
};

export const getRetrieveSkillEndorsements1QueryKey = (
  userId: number,
  skillId: number,
) => {
  return [`/users/${userId}/skills/${skillId}/endorsements`] as const;
};

export const getRetrieveSkillEndorsements1QueryOptions = <
  TData = Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
  TError = unknown,
>(
  userId: number,
  skillId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getRetrieveSkillEndorsements1QueryKey(userId, skillId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof retrieveSkillEndorsements1>>
  > = ({ signal }) => retrieveSkillEndorsements1(userId, skillId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(userId && skillId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RetrieveSkillEndorsements1QueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveSkillEndorsements1>>
>;
export type RetrieveSkillEndorsements1QueryError = unknown;

export function useRetrieveSkillEndorsements1<
  TData = Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
  TError = unknown,
>(
  userId: number,
  skillId: number,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
          TError,
          Awaited<ReturnType<typeof retrieveSkillEndorsements1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveSkillEndorsements1<
  TData = Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
  TError = unknown,
>(
  userId: number,
  skillId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
          TError,
          Awaited<ReturnType<typeof retrieveSkillEndorsements1>>
        >,
        "initialData"
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useRetrieveSkillEndorsements1<
  TData = Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
  TError = unknown,
>(
  userId: number,
  skillId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve skill endorsements
 */

export function useRetrieveSkillEndorsements1<
  TData = Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
  TError = unknown,
>(
  userId: number,
  skillId: number,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof retrieveSkillEndorsements1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getRetrieveSkillEndorsements1QueryOptions(
    userId,
    skillId,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Allows a user to endorse another user's skill
 * @summary Endorse a user skill
 */
export const endorseUserSkill1 = (
  userId: number,
  skillId: number,
  skillEndorsement: SkillEndorsement,
  signal?: AbortSignal,
) => {
  return customInstance<SkillEndorsement>({
    url: `/users/${userId}/skills/${skillId}/endorsements`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: skillEndorsement,
    signal,
  });
};

export const getEndorseUserSkill1MutationOptions = <
  TError = string,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof endorseUserSkill1>>,
    TError,
    { userId: number; skillId: number; data: SkillEndorsement },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof endorseUserSkill1>>,
  TError,
  { userId: number; skillId: number; data: SkillEndorsement },
  TContext
> => {
  const mutationKey = ["endorseUserSkill1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof endorseUserSkill1>>,
    { userId: number; skillId: number; data: SkillEndorsement }
  > = (props) => {
    const { userId, skillId, data } = props ?? {};

    return endorseUserSkill1(userId, skillId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type EndorseUserSkill1MutationResult = NonNullable<
  Awaited<ReturnType<typeof endorseUserSkill1>>
>;
export type EndorseUserSkill1MutationBody = SkillEndorsement;
export type EndorseUserSkill1MutationError = string;

/**
 * @summary Endorse a user skill
 */
export const useEndorseUserSkill1 = <TError = string, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof endorseUserSkill1>>,
      TError,
      { userId: number; skillId: number; data: SkillEndorsement },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof endorseUserSkill1>>,
  TError,
  { userId: number; skillId: number; data: SkillEndorsement },
  TContext
> => {
  const mutationOptions = getEndorseUserSkill1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
